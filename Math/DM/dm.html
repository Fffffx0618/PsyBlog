
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="可达鸭的笔记本，记录了 ZJU-CS 的一些课程笔记。">
      
      
        <meta name="author" content="Fffffx">
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Discrete Mathematics and Application - Fffffx's Note</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      
  
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
    
      
      
    
  
  
  <style>:root{--md-admonition-icon--note:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M1%207.775V2.75C1%201.784%201.784%201%202.75%201h5.025c.464%200%20.91.184%201.238.513l6.25%206.25a1.75%201.75%200%200%201%200%202.474l-5.026%205.026a1.75%201.75%200%200%201-2.474%200l-6.25-6.25A1.75%201.75%200%200%201%201%207.775m1.5%200c0%20.066.026.13.073.177l6.25%206.25a.25.25%200%200%200%20.354%200l5.025-5.025a.25.25%200%200%200%200-.354l-6.25-6.25a.25.25%200%200%200-.177-.073H2.75a.25.25%200%200%200-.25.25ZM6%205a1%201%200%201%201%200%202%201%201%200%200%201%200-2%22/%3E%3C/svg%3E');--md-admonition-icon--abstract:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2.5%201.75v11.5c0%20.138.112.25.25.25h3.17a.75.75%200%200%201%200%201.5H2.75A1.75%201.75%200%200%201%201%2013.25V1.75C1%20.784%201.784%200%202.75%200h8.5C12.216%200%2013%20.784%2013%201.75v7.736a.75.75%200%200%201-1.5%200V1.75a.25.25%200%200%200-.25-.25h-8.5a.25.25%200%200%200-.25.25m13.274%209.537zl-4.557%204.45a.75.75%200%200%201-1.055-.008l-1.943-1.95a.75.75%200%200%201%201.062-1.058l1.419%201.425%204.026-3.932a.75.75%200%201%201%201.048%201.074M4.75%204h4.5a.75.75%200%200%201%200%201.5h-4.5a.75.75%200%200%201%200-1.5M4%207.75A.75.75%200%200%201%204.75%207h2a.75.75%200%200%201%200%201.5h-2A.75.75%200%200%201%204%207.75%22/%3E%3C/svg%3E');--md-admonition-icon--info:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M0%208a8%208%200%201%201%2016%200A8%208%200%200%201%200%208m8-6.5a6.5%206.5%200%201%200%200%2013%206.5%206.5%200%200%200%200-13M6.5%207.75A.75.75%200%200%201%207.25%207h1a.75.75%200%200%201%20.75.75v2.75h.25a.75.75%200%200%201%200%201.5h-2a.75.75%200%200%201%200-1.5h.25v-2h-.25a.75.75%200%200%201-.75-.75M8%206a1%201%200%201%201%200-2%201%201%200%200%201%200%202%22/%3E%3C/svg%3E');--md-admonition-icon--tip:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M3.499.75a.75.75%200%200%201%201.5%200v.996C5.9%202.903%206.793%203.65%207.662%204.376l.24.202c-.036-.694.055-1.422.426-2.163C9.1.873%2010.794-.045%2012.622.26%2014.408.558%2016%201.94%2016%204.25c0%201.278-.954%202.575-2.44%202.734l.146.508.065.22c.203.701.412%201.455.476%202.226.142%201.707-.4%203.03-1.487%203.898C11.714%2014.671%2010.27%2015%208.75%2015h-6a.75.75%200%200%201%200-1.5h1.376a4.5%204.5%200%200%201-.563-1.191%203.84%203.84%200%200%201-.05-2.063%204.65%204.65%200%200%201-2.025-.293.75.75%200%200%201%20.525-1.406c1.357.507%202.376-.006%202.698-.318l.009-.01a.747.747%200%200%201%201.06%200%20.75.75%200%200%201-.012%201.074c-.912.92-.992%201.835-.768%202.586.221.74.745%201.337%201.196%201.621H8.75c1.343%200%202.398-.296%203.074-.836.635-.507%201.036-1.31.928-2.602-.05-.603-.216-1.224-.422-1.93l-.064-.221c-.12-.407-.246-.84-.353-1.29a2.4%202.4%200%200%201-.507-.441%203.1%203.1%200%200%201-.633-1.248.75.75%200%200%201%201.455-.364c.046.185.144.436.31.627.146.168.353.305.712.305.738%200%201.25-.615%201.25-1.25%200-1.47-.95-2.315-2.123-2.51-1.172-.196-2.227.387-2.706%201.345-.46.92-.27%201.774.019%203.062l.042.19.01.05c.348.443.666.949.94%201.553a.75.75%200%201%201-1.365.62c-.553-1.217-1.32-1.94-2.3-2.768L6.7%205.527c-.814-.68-1.75-1.462-2.692-2.619a3.7%203.7%200%200%200-1.023.88c-.406.495-.663%201.036-.722%201.508.116.122.306.21.591.239.388.038.797-.06%201.032-.19a.75.75%200%200%201%20.728%201.31c-.515.287-1.23.439-1.906.373-.682-.067-1.473-.38-1.879-1.193L.75%205.677V5.5c0-.984.48-1.94%201.077-2.664.46-.559%201.05-1.055%201.673-1.353z%22/%3E%3C/svg%3E');--md-admonition-icon--success:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M13.78%204.22a.75.75%200%200%201%200%201.06l-7.25%207.25a.75.75%200%200%201-1.06%200L2.22%209.28a.75.75%200%200%201%20.018-1.042.75.75%200%200%201%201.042-.018L6%2010.94l6.72-6.72a.75.75%200%200%201%201.06%200%22/%3E%3C/svg%3E');--md-admonition-icon--question:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M0%208a8%208%200%201%201%2016%200A8%208%200%200%201%200%208m8-6.5a6.5%206.5%200%201%200%200%2013%206.5%206.5%200%200%200%200-13M6.92%206.085h.001a.749.749%200%201%201-1.342-.67c.169-.339.436-.701.849-.977C6.845%204.16%207.369%204%208%204a2.76%202.76%200%200%201%201.637.525c.503.377.863.965.863%201.725%200%20.448-.115.83-.329%201.15-.205.307-.47.513-.692.662-.109.072-.22.138-.313.195l-.006.004a6%206%200%200%200-.26.16%201%201%200%200%200-.276.245.75.75%200%200%201-1.248-.832c.184-.264.42-.489.692-.661q.154-.1.313-.195l.007-.004c.1-.061.182-.11.258-.161a1%201%200%200%200%20.277-.245C8.96%206.514%209%206.427%209%206.25a.61.61%200%200%200-.262-.525A1.27%201.27%200%200%200%208%205.5c-.369%200-.595.09-.74.187a1%201%200%200%200-.34.398M9%2011a1%201%200%201%201-2%200%201%201%200%200%201%202%200%22/%3E%3C/svg%3E');--md-admonition-icon--warning:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.457%201.047c.659-1.234%202.427-1.234%203.086%200l6.082%2011.378A1.75%201.75%200%200%201%2014.082%2015H1.918a1.75%201.75%200%200%201-1.543-2.575Zm1.763.707a.25.25%200%200%200-.44%200L1.698%2013.132a.25.25%200%200%200%20.22.368h12.164a.25.25%200%200%200%20.22-.368Zm.53%203.996v2.5a.75.75%200%200%201-1.5%200v-2.5a.75.75%200%200%201%201.5%200M9%2011a1%201%200%201%201-2%200%201%201%200%200%201%202%200%22/%3E%3C/svg%3E');--md-admonition-icon--failure:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2.344%202.343za8%208%200%200%201%2011.314%2011.314A8.002%208.002%200%200%201%20.234%2010.089a8%208%200%200%201%202.11-7.746m1.06%2010.253a6.5%206.5%200%201%200%209.108-9.275%206.5%206.5%200%200%200-9.108%209.275M6.03%204.97%208%206.94l1.97-1.97a.749.749%200%200%201%201.275.326.75.75%200%200%201-.215.734L9.06%208l1.97%201.97a.749.749%200%200%201-.326%201.275.75.75%200%200%201-.734-.215L8%209.06l-1.97%201.97a.749.749%200%200%201-1.275-.326.75.75%200%200%201%20.215-.734L6.94%208%204.97%206.03a.75.75%200%200%201%20.018-1.042.75.75%200%200%201%201.042-.018%22/%3E%3C/svg%3E');--md-admonition-icon--danger:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M9.504.43a1.516%201.516%200%200%201%202.437%201.713L10.415%205.5h2.123c1.57%200%202.346%201.909%201.22%203.004l-7.34%207.142a1.25%201.25%200%200%201-.871.354h-.302a1.25%201.25%200%200%201-1.157-1.723L5.633%2010.5H3.462c-1.57%200-2.346-1.909-1.22-3.004zm1.047%201.074L3.286%208.571A.25.25%200%200%200%203.462%209H6.75a.75.75%200%200%201%20.694%201.034l-1.713%204.188%206.982-6.793A.25.25%200%200%200%2012.538%207H9.25a.75.75%200%200%201-.683-1.06l2.008-4.418.003-.006-.004-.009-.006-.006-.008-.001q-.005%200-.009.004%22/%3E%3C/svg%3E');--md-admonition-icon--bug:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M4.72.22a.75.75%200%200%201%201.06%200l1%20.999a3.5%203.5%200%200%201%202.441%200l.999-1a.748.748%200%200%201%201.265.332.75.75%200%200%201-.205.729l-.775.776c.616.63.995%201.493.995%202.444v.327q0%20.15-.025.292c.408.14.764.392%201.029.722l1.968-.787a.75.75%200%200%201%20.556%201.392L13%207.258V9h2.25a.75.75%200%200%201%200%201.5H13v.5q-.002.615-.141%201.186l2.17.868a.75.75%200%200%201-.557%201.392l-2.184-.873A5%205%200%200%201%208%2016a5%205%200%200%201-4.288-2.427l-2.183.873a.75.75%200%200%201-.558-1.392l2.17-.868A5%205%200%200%201%203%2011v-.5H.75a.75.75%200%200%201%200-1.5H3V7.258L.971%206.446a.75.75%200%200%201%20.558-1.392l1.967.787c.265-.33.62-.583%201.03-.722a1.7%201.7%200%200%201-.026-.292V4.5c0-.951.38-1.814.995-2.444L4.72%201.28a.75.75%200%200%201%200-1.06m.53%206.28a.75.75%200%200%200-.75.75V11a3.5%203.5%200%201%200%207%200V7.25a.75.75%200%200%200-.75-.75ZM6.173%205h3.654A.17.17%200%200%200%2010%204.827V4.5a2%202%200%201%200-4%200v.327c0%20.096.077.173.173.173%22/%3E%3C/svg%3E');--md-admonition-icon--example:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5%205.782V2.5h-.25a.75.75%200%200%201%200-1.5h6.5a.75.75%200%200%201%200%201.5H11v3.282l3.666%205.76C15.619%2013.04%2014.543%2015%2012.767%2015H3.233c-1.776%200-2.852-1.96-1.899-3.458Zm-2.4%206.565a.75.75%200%200%200%20.633%201.153h9.534a.75.75%200%200%200%20.633-1.153L12.225%2010.5h-8.45ZM9.5%202.5h-3V6c0%20.143-.04.283-.117.403L4.73%209h6.54L9.617%206.403A.75.75%200%200%201%209.5%206Z%22/%3E%3C/svg%3E');--md-admonition-icon--quote:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M1.75%202.5h10.5a.75.75%200%200%201%200%201.5H1.75a.75.75%200%200%201%200-1.5m4%205h8.5a.75.75%200%200%201%200%201.5h-8.5a.75.75%200%200%201%200-1.5m0%205h8.5a.75.75%200%200%201%200%201.5h-8.5a.75.75%200%200%201%200-1.5M2.5%207.75v6a.75.75%200%200%201-1.5%200v-6a.75.75%200%200%201%201.5%200%22/%3E%3C/svg%3E');}</style>



    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW+WenKai+Screen,+Microsoft+YaHei,+sans-serif:300,300i,400,400i,700,700i%7CJetBrains+Mono,+Sarasa+Mono+SC,+Consolas,+monospace:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"LXGW WenKai Screen, Microsoft YaHei, sans-serif";--md-code-font:"JetBrains Mono, Sarasa Mono SC, Consolas, monospace"}</style>
      
    
    
      <link rel="stylesheet" href="https://fonts.loli.net/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap">
    
      <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sarasa-gothic@0.43.0/css/sarasa-mono-sc.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/one-dark.min.css">
    
      <link rel="stylesheet" href="../../stylesheets/blueTopaz.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="blue-grey">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#discrete-mathematics-and-application" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Fffffx&#39;s Note" class="md-header__button md-logo" aria-label="Fffffx's Note" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m19.07 14.88 2.05 2.05L15.06 23H13v-2.06zm1.97-1.75c.14 0 .27.06.38.17l1.28 1.28c.22.21.22.56 0 .77l-1 1-2.05-2.05 1-1c.11-.11.25-.17.39-.17M17 4v6l-2-2-2 2V4H9v16h2v2H7c-1.05 0-2-.95-2-2v-1H3v-2h2v-4H3v-2h2V7H3V5h2V4a2 2 0 0 1 2-2h12c1.05 0 2 .95 2 2v6l-2 2V4zM5 5v2h2V5zm0 6v2h2v-2zm0 6v2h2v-2z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Fffffx's Note
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Discrete Mathematics and Application
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="blue-grey"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue-grey" data-md-color-accent="teal"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/Fffffx0618/PsyBlog" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    Fffffx
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../index.html" class="md-tabs__link">
          
  
  
    
  
  首页

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../blog/index.html" class="md-tabs__link">
          
  
  
    
  
  我的Blog

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../Language/index.html" class="md-tabs__link">
          
  
  
    
  
  编程语言

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../Algorithm/index.html" class="md-tabs__link">
          
  
  
    
  
  程序算法

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../System/index.html" class="md-tabs__link">
          
  
  
    
  
  体系结构

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../index.html" class="md-tabs__link">
          
  
  
    
  
  数学基础

        </a>
      </li>
    
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../Develop/index.md" class="md-tabs__link">
        
  
  
    
  
  前后端开发

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Fffffx&#39;s Note" class="md-nav__button md-logo" aria-label="Fffffx's Note" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m19.07 14.88 2.05 2.05L15.06 23H13v-2.06zm1.97-1.75c.14 0 .27.06.38.17l1.28 1.28c.22.21.22.56 0 .77l-1 1-2.05-2.05 1-1c.11-.11.25-.17.39-.17M17 4v6l-2-2-2 2V4H9v16h2v2H7c-1.05 0-2-.95-2-2v-1H3v-2h2v-4H3v-2h2V7H3V5h2V4a2 2 0 0 1 2-2h12c1.05 0 2 .95 2 2v6l-2 2V4zM5 5v2h2V5zm0 6v2h2v-2zm0 6v2h2v-2z"/></svg>

    </a>
    Fffffx's Note
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/Fffffx0618/PsyBlog" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    Fffffx
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../index.html" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    首页
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../blog/index.html" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    我的Blog
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../Language/index.html" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    编程语言
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../Algorithm/index.html" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    程序算法
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../System/index.html" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    体系结构
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../index.html" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    
  
    数学基础
  

    
  </span>
  
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Develop/index.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    前后端开发
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
                




              
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/Fffffx0618/PsyBlog/edit/master/docs/Math/DM/dm.md" title="编辑此页" class="md-content__button md-icon" rel="edit">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg>
    </a>
  
  
    
      
    
    <a href="https://github.com/Fffffx0618/PsyBlog/raw/master/docs/Math/DM/dm.md" title="查看本页的源代码" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"/></svg>
    </a>
  


<h1 id="discrete-mathematics-and-application">Discrete Mathematics and Application<a class="headerlink" href="#discrete-mathematics-and-application" title="Permanent link">&para;</a></h1>
<h1 id="ch1-logic--proofs">Ch1 Logic &amp; Proofs<a class="headerlink" href="#ch1-logic--proofs" title="Permanent link">&para;</a></h1>
<h2 id="11-propositional-logic">1.1 Propositional Logic<a class="headerlink" href="#11-propositional-logic" title="Permanent link">&para;</a></h2>
<h3 id="1-propositions">1. Propositions<a class="headerlink" href="#1-propositions" title="Permanent link">&para;</a></h3>
<p><u>A proposition is a <strong>declarative sentence</strong> (that is, a sentence that declares a fact) that is either <code>true</code> or <code>false</code>, but not both.</u></p>
<ul>
<li><strong>Paradox (悖论)</strong> 不属于命题（e.g. <em>This statement is false.</em> or <em>I'm lying.</em>）</li>
</ul>
<p><strong>Propositional variable / Sentential variables (命题变量)</strong>：Small letters such as <span class="arithmatex">\(p,q,r,s,\dots\)</span> used to present propositions.</p>
<p><strong>Propositional logic / Propositional calculus (命题逻辑)</strong>：The area of logic that deals with propositions.</p>
<p><strong>Truth value(真值)</strong>：T (true proposition), or F (false proposition)</p>
<p>We call a series of propositions <strong><mark>consistent</mark> (一致的)</strong> if they can possibly be satisfied at the same time.</p>
<h3 id="2-connectives">2. Connectives<a class="headerlink" href="#2-connectives" title="Permanent link">&para;</a></h3>
<h4 id="logical-operators">Logical Operators<a class="headerlink" href="#logical-operators" title="Permanent link">&para;</a></h4>
<p><strong>Logical operator</strong> or <strong>Logical Connective</strong>: be used to form <strong>compound propositions</strong> from existing propositions.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Connectives</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">negation (NOT)</td>
<td style="text-align: center;"><span class="arithmatex">\(¬p\)</span></td>
<td style="text-align: center;"><span class="arithmatex">\(~p, -p, p', Np, \text{and } !p\)</span></td>
</tr>
<tr>
<td style="text-align: left;">和取 conjunction (AND)</td>
<td style="text-align: center;"><span class="arithmatex">\(p∧q\)</span></td>
<td style="text-align: center;">"but" = "and"</td>
</tr>
<tr>
<td style="text-align: left;">析取 disjunction (OR)</td>
<td style="text-align: center;"><span class="arithmatex">\(p∨q\)</span></td>
<td style="text-align: center;">an inclusive or</td>
</tr>
<tr>
<td style="text-align: left;">亦或 Exclusive Or (XOR)</td>
<td style="text-align: center;"><span class="arithmatex">\(p⊕q\)</span></td>
<td style="text-align: center;">an exclusive or</td>
</tr>
<tr>
<td style="text-align: left;">条件 Conditional (IF-THEN)</td>
<td style="text-align: center;"><span class="arithmatex">\(p→q\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">双条件 Biconditional (IF AND ONLY IF)</td>
<td style="text-align: center;"><span class="arithmatex">\(p↔q\)</span></td>
<td style="text-align: center;">参见下节介绍</td>
</tr>
</tbody>
</table>
<ul>
<li>英语中的单词 or 既可以表示 <strong>inclusive or</strong> 也可以表示 <strong>exclusive or</strong>（e.g. <em>George was born in 1956 or 1957.</em>），取决于具体语境。</li>
</ul>
<p>逻辑运算符的<strong>优先级(precedence)</strong> 如下：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">¬</th>
<th style="text-align: center;">∧</th>
<th style="text-align: center;">∨</th>
<th style="text-align: center;">→</th>
<th style="text-align: center;">↔</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<h4 id="conditional-statements">Conditional Statements<a class="headerlink" href="#conditional-statements" title="Permanent link">&para;</a></h4>
<p><mark><strong>Implication</strong> or <strong>Conditional statement</strong></mark> ：<span class="arithmatex">\(p→q\)</span> is false when <span class="arithmatex">\(p\)</span> is true and <span class="arithmatex">\(q\)</span> is false, and true otherwise.</p>
<ul>
<li><strong>p :</strong> <strong>假设(hypothesis / antecedent / premise)</strong></li>
<li><strong>q :</strong> <strong>结论(conclusion / consequence)</strong></li>
</ul>
<p>对于推断 p→q可定义以下条件语句：</p>
<ul>
<li><strong>Converse (逆命题)</strong>：<span class="arithmatex">\(q→p\)</span></li>
<li><strong>Inverse (否命题)</strong>：<span class="arithmatex">\(¬p→¬q\)</span></li>
<li><strong>Contrapositive (逆否命题)</strong>：<span class="arithmatex">\(¬q→¬p\)</span></li>
</ul>
<p>When two compound propositions always have the same truth values, regardless of the truth values of its propositional variables, we call them <strong><mark>equivalent</mark>（等价的）</strong>.</p>
<ul>
<li>
<p>The <strong><em>contrapositive</em></strong> has the <strong>same</strong> truth values as the original implication.</p>
</li>
<li>
<p>The <strong><em>converse</em></strong> and the <strong><em>inverse</em></strong> of a conditional statement are also <strong>equivalent</strong>.</p>
</li>
</ul>
<p><strong><mark>Biconditional statement (双条件语句)</mark></strong>：The biconditional statement p↔q is the propostion “p if and only if q.” </p>
<h3 id="3-truth-table">3. Truth Table<a class="headerlink" href="#3-truth-table" title="Permanent link">&para;</a></h3>
<p>要学会画<strong>真值表(truth table)</strong>。</p>
<ul>
<li>n个不同的布尔变量所画的真值表应有 <span class="arithmatex">\(2^{n}\)</span> 行。</li>
</ul>
<h3 id="4-logic-and-bit-operatons">4. Logic and Bit Operatons<a class="headerlink" href="#4-logic-and-bit-operatons" title="Permanent link">&para;</a></h3>
<p><strong>Bit</strong>: a symbol with two possible values , namely, 0 and 1.</p>
<p><strong>Boolean variable</strong>: one whose value is either true or false.</p>
<h2 id="12-applications-of-propositional-logic">1.2 Applications of Propositional Logic<a class="headerlink" href="#12-applications-of-propositional-logic" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p>Translating English to Propositional Logic</p>
</li>
<li>
<p>System Specifications</p>
</li>
<li>
<p>System specifications should be <strong>consistent</strong>.</p>
</li>
<li>
<p>Logic Puzzles</p>
</li>
</ul>
<h2 id="13-propositional-equivalences">1.3 Propositional Equivalences<a class="headerlink" href="#13-propositional-equivalences" title="Permanent link">&para;</a></h2>
<h3 id="1-introduction">1. Introduction<a class="headerlink" href="#1-introduction" title="Permanent link">&para;</a></h3>
<ul>
<li>A <strong>tautology (永真)</strong> is a proposition which is always true.  Example: $p ∨¬p $</li>
<li>A <strong>contradiction (永假)</strong> is a proposition which is always false.  Example: $p ∧¬p $</li>
<li>A <strong>contingency (可能式)</strong> is a proposition which is neither a tautology nor a  contradiction, such as $ p$</li>
</ul>
<p><strong>Propositional Satisfiability</strong></p>
<ul>
<li>A compound proposition is <strong><mark>satisfiable</mark></strong> if there is an assignment of truth values to its  variables that makes it true. </li>
<li>A compound proposition is <strong><mark>unsatisfiable</mark></strong> when it is false for all assignments of truth  values to its variables.</li>
</ul>
<p><strong>Equivalent</strong></p>
<ul>
<li>
<p>The propositions <span class="arithmatex">\(p\)</span> and <span class="arithmatex">\(q\)</span> are called <mark><strong>logically equivalent（逻辑等值）</strong></mark> if <span class="arithmatex">\(p ↔ q\)</span> is a  tautology.</p>
</li>
<li>
<p>Notation: <span class="arithmatex">\(p ⇔ q\)</span> or <span class="arithmatex">\(p ≡ q\)</span></p>
</li>
</ul>
<p><strong>Other logical operators</strong></p>
<ul>
<li><u>Sheffer stroke</u> |:  $p|q ≡ ¬(p ∧ q) $ NAND </li>
<li><u>Peirce arrow</u> ↓:  $p ↓ q ≡ ¬(p ∨ q) $ NOR</li>
</ul>
<h3 id="2-logical-laws">2. Logical Laws<a class="headerlink" href="#2-logical-laws" title="Permanent link">&para;</a></h3>
<ul>
<li>可以用真值表来证明一些基本的逻辑定律：对于涉及到<span class="arithmatex">\(n\)</span>个变量的两个命题，画出 <span class="arithmatex">\(2^n\)</span> 种可能的变量取值下的真值表，若两个命题的值都相同，则说明这两个命题是逻辑等值的。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: left;">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">统一律 Identity Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∧T ≡ p\)</span>   <span class="arithmatex">\(p∨F ≡ p\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">零一律 Domination Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∨T ≡ T\)</span>   <span class="arithmatex">\(p∧F ≡ F\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">幂等律 Idempotent Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∧p ≡ p\)</span>   <span class="arithmatex">\(p∨p ≡ p\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">对合律 Double Negation Law</td>
<td style="text-align: center;"><span class="arithmatex">\(¬¬p ≡ p\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">交换律 Commutative Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∨q ≡ q∨p\)</span>   <span class="arithmatex">\(p∧q ≡ q∧p\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">结合律 Associative Laws</td>
<td style="text-align: center;"><span class="arithmatex">\((p∨q)∨r ≡ p∨(q∨r)\)</span>    <span class="arithmatex">\((p∧q)∧r ≡ p∧(q∧r)\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">分配律 Distributive Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∨(q∧r) ≡ (p∨q)∧(p∨r)\)</span>   $ p∧(q∨r) ≡ (p∧q)∨(p∧r)$</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><strong>德·摩根律 De Morgan's Laws</strong></td>
<td style="text-align: center;"><span class="arithmatex">\(¬(p∨q) ≡ ¬p∧¬q\)</span>    <span class="arithmatex">\(¬(p∧q) = ¬p∨¬q\)</span></td>
<td style="text-align: left;"><strong>重要</strong></td>
</tr>
<tr>
<td style="text-align: left;">否定律 Negation Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∨¬p ≡ T\)</span>   <span class="arithmatex">\(p∧¬p ≡ F\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">吸收律 Absorption Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p∨(p∧q) ≡ p\)</span>   <span class="arithmatex">\(p∧(p∨q) ≡ p\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">逆否律 Contrapositive Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p→q ≡ ¬q→¬p\)</span></td>
<td style="text-align: left;">命题与它的逆否命题等价</td>
</tr>
<tr>
<td style="text-align: left;"><strong>导出律 Exportation Laws</strong></td>
<td style="text-align: center;"><span class="arithmatex">\((p∧q)→r ≡ p→(q→r)\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Absurdity Laws</td>
<td style="text-align: center;"><span class="arithmatex">\((p→q)∧(p→¬q) ≡ ¬p\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><strong>蕴含律 Implication Laws</strong></td>
<td style="text-align: center;"><span class="arithmatex">\(p→q ≡ ¬p∨q\)</span></td>
<td style="text-align: left;">用于去掉箭头</td>
</tr>
<tr>
<td style="text-align: left;">Equivalence Laws</td>
<td style="text-align: center;"><span class="arithmatex">\(p↔q ≡ (p→q)∧(q→p)\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">### 3. The Dual of a Compound Proposition</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>The <strong>dual对偶</strong> of compound proposition that contains only the logical operators  <span class="arithmatex">\(∨\)</span> , <span class="arithmatex">\(∧\)</span> and <span class="arithmatex">\(¬\)</span> is the proposition obtained by replacing each <span class="arithmatex">\(∨\)</span> by <span class="arithmatex">\(∧\)</span>,each <span class="arithmatex">\(∧\)</span> by <span class="arithmatex">\(∨\)</span>,each <span class="arithmatex">\(T\)</span> by <span class="arithmatex">\(F\)</span> and each <span class="arithmatex">\(F\)</span> by <span class="arithmatex">\(T\)</span>. The dual of <span class="arithmatex">\(S\)</span> is denoted by <span class="arithmatex">\(S^{*}\)</span>.  </p>
<ul>
<li>
<p><span class="arithmatex">\(S = (p ∨ ¬q) ∧ r ∨ T\)</span>      <span class="arithmatex">\(S^{*} = (p ∧ ¬q) ∨ r ∧ F\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(S = (p ∧ q) → (p ∨ q) ≡ ¬(p ∧ q) ∨ (p ∨ q)\)</span>     <span class="arithmatex">\(S^{*} = ¬(p ∨ q) ∧ (p ∧ q)\)</span> </p>
</li>
</ul>
<p>【Theorem】 let <span class="arithmatex">\(s\)</span> and <span class="arithmatex">\(t\)</span> are two compound propositions, <strong><span class="arithmatex">\(s\)</span> ≡ <span class="arithmatex">\(t\)</span> if and  only if <span class="arithmatex">\(s^*\)</span> ≡ <span class="arithmatex">\(t^*\)</span></strong> .</p>
<h3 id="4-functionally-complete-collection-of-logical-operators">4. Functionally Complete Collection of Logical Operators<a class="headerlink" href="#4-functionally-complete-collection-of-logical-operators" title="Permanent link">&para;</a></h3>
<p>只需要部分运算符就可以表示出所有可能的运算，</p>
<p>称这样的一个运算符集合为<strong>全功能集(Functionally Complete Collection)</strong></p>
<p><strong>极小全功能集</strong>：<span class="arithmatex">\(\{¬,∨,∧,→,↔ \}\{¬,∨,∧\}, \{¬,∧\}\{¬,∨\}, \{∣\}, \{↓\}\)</span> 等。</p>
<blockquote>
<ul>
<li><span class="arithmatex">\(p∨q≡¬(¬p∧¬q)\)</span></li>
<li><span class="arithmatex">\(¬p≡p∣p\)</span></li>
<li><span class="arithmatex">\(p∧q≡¬(p∣q)≡(p∣q)∣(p∣q)\)</span></li>
<li><span class="arithmatex">\(p∨q≡¬(¬p∧¬q)≡¬p∣¬q≡(p∣p)∣(q∣q)\)</span></li>
</ul>
</blockquote>
<h3 id="5-propositional-normal-forms">5. Propositional Normal Forms<a class="headerlink" href="#5-propositional-normal-forms" title="Permanent link">&para;</a></h3>
<h4 id="51-dnfcnf">5.1 DNF/CNF<a class="headerlink" href="#51-dnfcnf" title="Permanent link">&para;</a></h4>
<ul>
<li>A <strong>字面量(literal)</strong> is a variable or its negation.</li>
<li>Conjunctions with literals as conjuncts are called <strong>合取子句(conjunctive clauses)</strong> (clauses). <u>通过 AND 连接起来的一组字面量</u>。</li>
</ul>
<p><strong>Propositional Normal Forms</strong>：</p>
<ul>
<li><strong>析取范式(Disjunctive Normal Form, DNF)</strong></li>
</ul>
<p>A formula is said to be in <strong>disjunctive normal form</strong> if it is written as a disjunction, in which all the terms are conjunctions of literals. </p>
<blockquote>
<p>e.g.  <span class="arithmatex">\((p∧q)∨(p∧¬q)\)</span></p>
</blockquote>
<ul>
<li>最外面一层的运算符都是析取 <span class="arithmatex">\(∨\)</span></li>
<li>
<p>括号内的运算符都是合取 <span class="arithmatex">\(∧\)</span></p>
</li>
<li>
<p><strong>合取范式(Conjunctive Normal Form, CNF)</strong></p>
</li>
</ul>
<blockquote>
<p>e.g. <span class="arithmatex">\((p ∨ q)∧(p∨¬q)\)</span></p>
</blockquote>
<p>和 DNF 的定义相反；把 <span class="arithmatex">\(∧\)</span> 和 <span class="arithmatex">\(∨\)</span> 互换。</p>
<h4 id="52-full-dnf--full-cnf">5.2 Full DNF &amp; Full CNF<a class="headerlink" href="#52-full-dnf--full-cnf" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Minterm(极小项)</strong> : a conjunctive of literals in which each variable is represented <u>exactly once</u>.</li>
<li><strong>Maxterm(极大项)</strong> : a disjunctive of literals in which each variable is represented <u>exactly once</u>.</li>
</ul>
<p><strong>Full Disjunctive Normal Form(主析取范式)</strong>：</p>
<blockquote>
<p>e.g. <span class="arithmatex">\((p\and \neg q \and r)\or(\neg p \and q \and r)\or (p \and q \and r)=\sum m(3,5,7)\)</span></p>
</blockquote>
<p>If a formula is expressed as a disjunction of minterms, it is said to be in <strong>full disjunctive normal form</strong>.</p>
<ul>
<li>每个最小项对应真值表中 <span class="arithmatex">\(T\)</span> 的恰好一行。</li>
</ul>
<p><strong>Full Conjuctive Normal Form(主合取范式)</strong>：</p>
<blockquote>
<p>e.g. <span class="arithmatex">\((p\or \neg q \or r)\and(\neg p \or q \or r)\and (p \or q \or r)=\sum M(0,2,4)\)</span></p>
</blockquote>
<ul>
<li>取出所有真值表为中为 F 的位置，写出 <span class="arithmatex">\(¬f\)</span>。</li>
<li>对 <span class="arithmatex">\(¬f\)</span> 应用 De Morgan's Laws，可以将式子中的合取析取互换，从而求得 FCNF。</li>
</ul>
<h2 id="14-predicates-and-quantifiers">1.4 Predicates and Quantifiers<a class="headerlink" href="#14-predicates-and-quantifiers" title="Permanent link">&para;</a></h2>
<h3 id="1-predicates">1. Predicates<a class="headerlink" href="#1-predicates" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Propositional functions命题函数</strong> become propositions (and have truth values) when <u>their variables are each replaced by a value from the domain</u> or <u>bound by a quantifier</u>. </p>
</li>
<li>
<p>The statement <span class="arithmatex">\(P(x_{1}, x_{2}, x_{3})\)</span> is said to be the value of the propositional function <span class="arithmatex">\(P\)</span> at <span class="arithmatex">\(x_{1}, x_{2}, x_{3}\)</span>. </p>
</li>
<li>
<p>A statement of the form  <span class="arithmatex">\(P(x_{1}, x_{2}, x_{3})\)</span> is the value of the propositional function <span class="arithmatex">\(P\)</span> at the <span class="arithmatex">\(n-tuple \space (x_1,x_2,…, x_n)\)</span> and <span class="arithmatex">\(P\)</span> is called <strong>a n-ary predicate n位谓词</strong>.</p>
</li>
</ul>
<p>Predicates are also used to establish the correctness of computer programs. </p>
<ul>
<li><strong>preconditions前置条件</strong> : the statements that describe <strong>valid input</strong> </li>
<li><strong>postconditions后置条件</strong> : the conditions that the <strong>output</strong> should satisfy when the  program has run</li>
</ul>
<h3 id="2-quantifiers">2. Quantifiers<a class="headerlink" href="#2-quantifiers" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>全称量词(universal quantifier)</strong> <span class="arithmatex">\(∀\)</span> ：都是真才为真，存在一个为假就为假。可以转化为合取。</li>
<li><strong>存在量词(existential quantifier)</strong> <span class="arithmatex">\(∃\)</span> ：都是假才为假，存在一个为真就为真。可以转化为析取。</li>
<li><strong>唯一量词(uniqueless quantifier)</strong> <span class="arithmatex">\(∃!\)</span> ：有且仅有一个为真时才为真。</li>
</ul>
<p>我们在使用量词时，可能只要求对于某一范围内的 <span class="arithmatex">\(x\)</span> 成立，我们把此时 <span class="arithmatex">\(x\)</span> 的取值范围称为 <strong>讨论域</strong> (domain of discourse / universe of discourse)，一般简写为 <strong>domain</strong>。</p>
<ul>
<li><strong>量词的优先级(precedence of quantifiers)</strong></li>
<li>The quantifiers ∀ and ∃ have higher precedence(优先级) than <strong>all</strong> the logical operators.</li>
<li>If t<strong>he domain is finite</strong>, <u><strong>a universally quantified proposition</strong></u> is  equivalent to a <strong>conjunction</strong> of propositions without quantifiers and <u><strong>an existentially quantified proposition</strong></u> is equivalent to a <strong>disjunction</strong> of  propositions without quantifiers.</li>
</ul>
<h3 id="3-equivalences-in-predicate-logic">3. Equivalences in Predicate Logic<a class="headerlink" href="#3-equivalences-in-predicate-logic" title="Permanent link">&para;</a></h3>
<p>Statements involving predicates and quantifiers are logically <strong>equivalent</strong> if and only if they <strong>have the same truth value</strong> no matter</p>
<ul>
<li>代入了什么谓词选择 which predicates are substituted into these statements and</li>
<li>使用了什么讨论域 which domain of discourse is used for the variables in these propositional functions</li>
</ul>
<p>同样使用 <span class="arithmatex">\(≡\)</span> 符号来表示谓词逻辑中的等值。</p>
<p><strong>德摩根定律(De Morgan’s laws)</strong> 在谓词逻辑中也适用：</p>
<ul>
<li>
<p><span class="arithmatex">\(¬∀xP(x)≡∃x¬P(x)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(¬∃xP(x)≡∀x¬P(x)\)</span></p>
</li>
</ul>
<p>只有在 <span class="arithmatex">\(A(x)\)</span> 和 <span class="arithmatex">\(B(x)\)</span> 都输出真时，<span class="arithmatex">\(A(x)∧B(x)\)</span> 才为真，此时第一个等式的两侧都为真，否则两侧都为假。类似的可以证明第二个等式。</p>
<ul>
<li><span class="arithmatex">\(∀x(A(x)∧B(x))≡∀xA(x)∧∀xB(x)\)</span> , <span class="arithmatex">\(∃x(A(x)∨B(x))≡∃xA(x)∨∃xB(x)\)</span></li>
</ul>
<p>但是如果把上面的等式的 <span class="arithmatex">\(∧\)</span> 和 <span class="arithmatex">\(∨\)</span> 互换则不成立。容易举出反例。</p>
<ul>
<li><span class="arithmatex">\(∀x(A(x)∨B(x))≢∀xA(x)∨∀xB(x)\)</span> , <span class="arithmatex">\(∃x(A(x)∧B(x))≢∃xA(x)∧∃xB(x)\)</span></li>
</ul>
<p><u>For example, <span class="arithmatex">\(U\)</span>：the set of real numbers，<span class="arithmatex">\(Q(x)\)</span>：<span class="arithmatex">\(x\)</span> is a rational number，<span class="arithmatex">\(F(x)\)</span>：<span class="arithmatex">\(x\)</span> is an irrational  number</u></p>
<p>但这两个命题在其中一个方向上是正确的。</p>
<ul>
<li><span class="arithmatex">\(∀xA(x)∨∀xB(x)⇒∀x(A(x)∨B(x))\)</span> , <span class="arithmatex">\(∃x(A(x)∧B(x))⇒∃xA(x)∧∃xB(x)\)</span></li>
</ul>
<p>此外，还有：</p>
<p>(<span class="arithmatex">\(x\)</span> is not occurring in <span class="arithmatex">\(P\)</span>.)</p>
<p><span class="arithmatex">\(∀xA(x)∨P≡∀x(A(x)∨P)\)</span> , <span class="arithmatex">\(∀xA(x)∧P≡∀x(A(x)∧P)\)</span></p>
<p><span class="arithmatex">\(∃xA(x)∨P≡∃x(A(x)∨P)\)</span> , <span class="arithmatex">\(∃xA(x)∧P≡∃x(A(x)∧P)\)</span></p>
<p>(x is not occurring in <span class="arithmatex">\(B\)</span>.)</p>
<p><span class="arithmatex">\(∀x(B→A(x))≡B→∀xA(x)\)</span> , <span class="arithmatex">\(∃x(B→A(x))≡B→∃xA(x)\)</span></p>
<p><span class="arithmatex">\(∀x(A(x)→B)≡∃xA(x)→B\)</span> , <span class="arithmatex">\(∃x(A(x)→B)≡∀xA(x)→B\)</span></p>
<h2 id="15-nested-quantifiers">1.5 Nested Quantifiers<a class="headerlink" href="#15-nested-quantifiers" title="Permanent link">&para;</a></h2>
<p><strong>嵌套量词</strong>：Nest quantifiers are quantfiers that occur within <u>the scope of other quantifiers</u>.</p>
<h3 id="1-order-of-quantifiers">1. Order of Quantifiers<a class="headerlink" href="#1-order-of-quantifiers" title="Permanent link">&para;</a></h3>
<p>除非所有量词都是 <span class="arithmatex">\(∀\)</span> 或所有量词都是 <span class="arithmatex">\(∃\)</span>，否则量词的顺序是有意义的。</p>
<p>The order of nested quantifiers is <strong>important</strong> unless all the quantifiers are universal quantifiers or all the quantifiers are existential quantifiers.</p>
<h3 id="2-prenex-normal-form">2. Prenex Normal Form<a class="headerlink" href="#2-prenex-normal-form" title="Permanent link">&para;</a></h3>
<ul>
<li><span class="arithmatex">\(Q_{1}x_{1}Q_{2}x_{2}...Q_{n}x_{n}B\)</span>, where <span class="arithmatex">\(Q_{i}(i = 1,2,...n)\)</span> is <span class="arithmatex">\(∀\)</span> or <span class="arithmatex">\(∃\)</span>, <span class="arithmatex">\(B\)</span> is quantifier free(不含量词的公式).</li>
</ul>
<p>得到 <strong>PNF</strong>（<strong>前束范式</strong>）的步骤：</p>
<ol>
<li>消除所有的 $→ <span class="arithmatex">\(和\)</span> ↔$。</li>
<li>向内移动否定符号，注意应用德摩根定律。</li>
<li>对变量进行重命名，确定不同部分的变量不会冲突。</li>
<li>最后，将所有量词移动到最前面。</li>
</ol>
<h2 id="16-rules-of-inference">1.6 Rules of Inference<a class="headerlink" href="#16-rules-of-inference" title="Permanent link">&para;</a></h2>
<h3 id="1-arguments">1. Arguments<a class="headerlink" href="#1-arguments" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>An <strong>argument（论据）</strong> in propositional logic is a sequence of propositions.  All but the final proposition are called <strong>premises（前提）</strong>. The last statement is the <strong>conclusion（结论）</strong>.</p>
</li>
<li>
<p>An <strong>论据(argument)</strong> is a sequence of statements that end with a conclusion</p>
</li>
</ul>
<h3 id="2-valid-arguments--argument-form">2. Valid Arguments &amp; Argument Form<a class="headerlink" href="#2-valid-arguments--argument-form" title="Permanent link">&para;</a></h3>
<ul>
<li>An <strong>argument（论据）</strong> is <strong>valid</strong>(有效) if the truth of all its <strong>premises（前提）</strong> implies that the <u>conclusion</u> is true.   </li>
<li>An <strong>argument form</strong> is <strong>valid</strong> if no matter which particular propositions are substituted for the propositional variables in its premises, the conclusion is true if the premises are all true.</li>
<li>If the premises are <span class="arithmatex">\(p_{1}, p_{2}, ...p_{n}\)</span> and the conclusion is <span class="arithmatex">\(q\)</span> , then <span class="arithmatex">\(p_{1}∧p_{2}∧...∧p_{n}→q\)</span> is a <strong>tautology</strong>.</li>
</ul>
<h3 id="3-rules-of-inference">3. Rules of Inference<a class="headerlink" href="#3-rules-of-inference" title="Permanent link">&para;</a></h3>
<h4 id="1modus-ponens-假言推理">1)Modus Ponens 假言推理<a class="headerlink" href="#1modus-ponens-假言推理" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\((p∧(p→q))→q\)</span></p>
<h4 id="2modus-tollens-取拒式">2)Modus Tollens 取拒式<a class="headerlink" href="#2modus-tollens-取拒式" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\((¬ q ∧(p →q))→¬p\)</span></p>
<h4 id="3hypothetical-syllogism-假言三段论">3)Hypothetical Syllogism 假言三段论<a class="headerlink" href="#3hypothetical-syllogism-假言三段论" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\(((p →q) ∧ (q→r))→(p→ r)\)</span></p>
<h4 id="4disjunctive-syllogism-析取三段论">4)Disjunctive Syllogism 析取三段论<a class="headerlink" href="#4disjunctive-syllogism-析取三段论" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\((¬p∧(p ∨q))→q\)</span></p>
<h4 id="5addition-附加律">5)Addition 附加律<a class="headerlink" href="#5addition-附加律" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\(p →(p ∨q)\)</span></p>
<h4 id="6simplification-化简律">6)Simplification 化简律<a class="headerlink" href="#6simplification-化简律" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\((p∧q) → p\)</span></p>
<h4 id="7conjunction-合取律">7)Conjunction 合取律<a class="headerlink" href="#7conjunction-合取律" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology : <span class="arithmatex">\((（p） ∧ （q）) →(p ∧ q)\)</span></p>
<h4 id="8resolution-消解律">8)Resolution 消解律<a class="headerlink" href="#8resolution-消解律" title="Permanent link">&para;</a></h4>
<p>Corresponding Tautology :  <span class="arithmatex">\(( (p ∨ q)∧(\neg p ∨ r ) ) \rightarrow(q ∨ r)\)</span></p>
<ul>
<li>We use <strong>推理准则(rules of inference)</strong> to construct valid arguments</li>
</ul>
<h3 id="4-build-valid-arguments">4. Build Valid Arguments<a class="headerlink" href="#4-build-valid-arguments" title="Permanent link">&para;</a></h3>
<p>To prove an argument is valid or the conclusion follows logically from the hypotheses（假设）: </p>
<ol>
<li>Assume the hypotheses are true. 假定所有假设是对的</li>
<li>Use <strong>the rules of inference</strong> and <strong>logical equivalences</strong> to  determine that the conclusion is true.</li>
</ol>
<h3 id="5-fallacies">5. Fallacies<a class="headerlink" href="#5-fallacies" title="Permanent link">&para;</a></h3>
<h4 id="1the-fallacy-of-affirming-the-conclusion-肯定结论的谬误">1）The Fallacy of affirming the conclusion 肯定结论的谬误<a class="headerlink" href="#1the-fallacy-of-affirming-the-conclusion-肯定结论的谬误" title="Permanent link">&para;</a></h4>
<p>Method: Reasoning based on <span class="arithmatex">\(((p→q) ∧ q) → p\)</span></p>
<h4 id="2-the-fallacy-of-denying-the-hypothesis-否定假设的谬误">2) The Fallacy of denying the hypothesis 否定假设的谬误<a class="headerlink" href="#2-the-fallacy-of-denying-the-hypothesis-否定假设的谬误" title="Permanent link">&para;</a></h4>
<p>Method: Reasoning based on <span class="arithmatex">\(((p→q) ∧¬ p) → ¬ q\)</span></p>
<h3 id="6-handling-quantified-statements">6. Handling Quantified Statements<a class="headerlink" href="#6-handling-quantified-statements" title="Permanent link">&para;</a></h3>
<p><strong>Valid arguments for quantified statements</strong> are a sequence of statements. Each statement is either a premise or follows from previous statements by rules of inference.</p>
<h4 id="universal-instantiation-ui-全称实例">Universal Instantiation (UI) 全称实例<a class="headerlink" href="#universal-instantiation-ui-全称实例" title="Permanent link">&para;</a></h4>
<div class="arithmatex">\[
\frac{\forall x P(x)}{\therefore P(c)}
\]</div>
<h4 id="universal-generalization-ug-全称引入">Universal Generalization (UG) 全称引入<a class="headerlink" href="#universal-generalization-ug-全称引入" title="Permanent link">&para;</a></h4>
<div class="arithmatex">\[
\frac{P(c) \text{ for an arbitrary } c}{\therefore \forall x P(x)}
\]</div>
<h4 id="existential-instantiation-ei-存在实例">Existential Instantiation (EI) 存在实例<a class="headerlink" href="#existential-instantiation-ei-存在实例" title="Permanent link">&para;</a></h4>
<div class="arithmatex">\[
\frac{\exist x P(x)}{\therefore P(c)\text{ for some element}}
\]</div>
<h4 id="existential-generalization-eg-存在引入">Existential Generalization (EG) 存在引入<a class="headerlink" href="#existential-generalization-eg-存在引入" title="Permanent link">&para;</a></h4>
<div class="arithmatex">\[
\frac{P(c)\text{ for some element}}{\therefore \exist xP(x)}
\]</div>
<h3 id="7-the-mixed-use-of-propositional-and-quantitative-propositional-reasoning-rules">7. The mixed use of propositional and quantitative propositional reasoning rules<a class="headerlink" href="#7-the-mixed-use-of-propositional-and-quantitative-propositional-reasoning-rules" title="Permanent link">&para;</a></h3>
<h4 id="universal-modus-ponens-全称假言推理">Universal Modus Ponens 全称假言推理<a class="headerlink" href="#universal-modus-ponens-全称假言推理" title="Permanent link">&para;</a></h4>
<p>$$
\forall x (P(x) \rightarrow Q(x))\
\frac{</p>
<p>P(a), \text{ where } a \text{ is a particular element in the domain}
}{
  \therefore Q(a)
}
$$</p>
<h4 id="universal-modus-tollens-全称取拒式">Universal Modus Tollens 全称取拒式<a class="headerlink" href="#universal-modus-tollens-全称取拒式" title="Permanent link">&para;</a></h4>
<div class="arithmatex">\[
  \forall x (P(x) \rightarrow Q(x)) \\
\frac{
  \neg Q(a), \text{ where } a \text{ is a particular element in the domain}
}{
  \therefore \neg P(a)
}
\]</div>
<h2 id="17-introduction-to-proofs">1.7 Introduction to Proofs<a class="headerlink" href="#17-introduction-to-proofs" title="Permanent link">&para;</a></h2>
<h3 id="1-some-terminology">1. Some Terminology<a class="headerlink" href="#1-some-terminology" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Theorem</strong>（定理）: A statement that can be shown to be true</li>
<li><strong>Proposition</strong>（命题）: Less important theorem (also called result / fact)</li>
<li><strong>Proof</strong>（证明）: A valid argument that establishes the truth of a theorem</li>
<li><strong>Axioms</strong>（公理）: The underlying assumptions about mathematical structures,  or hypotheses of the theorem to be proved, or previously proved theorems. </li>
<li><strong>Lemma</strong>（引理） : A ‘helping theorem’ or a result which is needed to prove a theorem. </li>
<li><strong>Corollary</strong>（推论） :A result which follows directly from a theorem.</li>
<li><strong>Conjecture</strong>（猜想）:  A statement whose truth value is unknown.</li>
</ul>
<h3 id="2-formal-proofs">2. Formal Proofs<a class="headerlink" href="#2-formal-proofs" title="Permanent link">&para;</a></h3>
<p><strong>形式化证明(formal proof)</strong> v.s. <strong>非形式化证明(informal proof)</strong>：</p>
<ul>
<li>Formal Proofs：</li>
<li>All steps were supplied</li>
<li>The rules for each step in the  argument were given</li>
<li>Informal Proofs:</li>
<li>More than one rule of inference may be used in each step</li>
<li>Steps may be skipped</li>
<li>The axioms being assumed and the  rules of inference used are not explicity stated</li>
</ul>
<h3 id="3-proof-methods">3. Proof Methods<a class="headerlink" href="#3-proof-methods" title="Permanent link">&para;</a></h3>
<h4 id="31-direct-proof">3.1 Direct Proof<a class="headerlink" href="#31-direct-proof" title="Permanent link">&para;</a></h4>
<p><strong>直接证明法(direct proof)</strong> 证明 <span class="arithmatex">\(p→q\)</span>：</p>
<ul>
<li>通过<strong>推理规则(rules of inference)</strong>、公理、<strong>逻辑恒等式(logical equivalences)</strong> 等推出<span class="arithmatex">\(q\)</span>也为真。</li>
</ul>
<p>其余的证明方法都是<strong>间接证明法(indirect proof)</strong>。</p>
<h4 id="32-proof-by-contraposition">3.2 Proof by Contraposition<a class="headerlink" href="#32-proof-by-contraposition" title="Permanent link">&para;</a></h4>
<p>反证法可以看做对原命题的逆否命题的直接证明，根据逻辑恒等式：<span class="arithmatex">\(p→q≡¬q→¬p\)</span></p>
<ul>
<li>假设 <span class="arithmatex">\(¬q\)</span> 为真，推出 <span class="arithmatex">\(¬p\)</span> 也为真（or 推出 <span class="arithmatex">\(p\)</span> 为假），从而证明原命题。</li>
</ul>
<h4 id="34-vacuous-and-trivial-proof">3.4 Vacuous and Trivial Proof<a class="headerlink" href="#34-vacuous-and-trivial-proof" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>空证明(vacuous proof)</strong>：可通过证明 <span class="arithmatex">\(p\)</span> 为假来证明 $ p→q$ 为真。</li>
<li><strong>平凡证明(trivial proof)</strong>：可以通过证明 <span class="arithmatex">\(q\)</span> 为真来证明 <span class="arithmatex">\(p→q\)</span> 为真。</li>
</ul>
<h4 id="35-proof-by-contradiciton">3.5 Proof by Contradiciton<a class="headerlink" href="#35-proof-by-contradiciton" title="Permanent link">&para;</a></h4>
<p><strong>归谬证明法</strong>的步骤</p>
<ul>
<li>assumes <span class="arithmatex">\(p\)</span> is false.</li>
<li>derives a contradiction, usually of the form <span class="arithmatex">\(q ∧¬ q\)</span> which  establishes <span class="arithmatex">\(¬ p →F\)</span>.</li>
</ul>
<h4 id="36-proof-of-equivalence">3.6 Proof of Equivalence<a class="headerlink" href="#36-proof-of-equivalence" title="Permanent link">&para;</a></h4>
<p><strong>等价证明法</strong></p>
<p>(1)To prove the proposition “<span class="arithmatex">\(p\)</span> if and only if <span class="arithmatex">\(q\)</span>” </p>
<p>(2)To prove that several propositions <span class="arithmatex">\(p_{1}, p_{2} ,...,p_{n}\)</span> are equivalent  </p>
<ul>
<li>establish the implications <span class="arithmatex">\(p_{1}→ p_{2}, p_{2}→p_{3},...,p_{n}→p_{1}\)</span>  </li>
<li>$ p_{1}↔p_{2}↔...↔p_{n}≡(p_{1}→p_{2})∧(p_{2}→p_{3} )∧... ∧(p_{n}→p_{1})$</li>
</ul>
<h2 id="18-proof-method-and-strategy">1.8 Proof Method and Strategy<a class="headerlink" href="#18-proof-method-and-strategy" title="Permanent link">&para;</a></h2>
<h3 id="1-proof-method">1. Proof Method<a class="headerlink" href="#1-proof-method" title="Permanent link">&para;</a></h3>
<h4 id="穷举和分情况证明法-exhaustive-proof-and-proof-by-cases">穷举和分情况证明法 Exhaustive Proof and Proof by Cases<a class="headerlink" href="#穷举和分情况证明法-exhaustive-proof-and-proof-by-cases" title="Permanent link">&para;</a></h4>
<p>Using the method of proof by cases to show that <span class="arithmatex">\((p_{1} ∨ p_{2} ∨…∨ p_{n}  ) → q\)</span> (穷举证明法)</p>
<p>$ (p_{1} ∨ p_{2} ∨...∨p_{n} ) → q ≡ (p_{1} →q) ∧(p_{2} →q) ∧...∧ (p_{n} →q)$ (分情况证明法)</p>
<h4 id="存在性证明-existence-proofs">存在性证明 Existence Proofs<a class="headerlink" href="#存在性证明-existence-proofs" title="Permanent link">&para;</a></h4>
<p>Using <strong>constructive existence proof 构造存在性证明</strong> to establish the truth of <span class="arithmatex">\(∃xP( x)\)</span>. </p>
<ul>
<li>Establish $P(c) $is true for some <span class="arithmatex">\(c\)</span> in the domain.</li>
<li>Then <span class="arithmatex">\(∃xP( x)\)</span> is true by Existential Generalization (EG)</li>
</ul>
<p>Using <strong>nonconstructive existence proof 非构造存在性证明</strong> to establish the truth of  <span class="arithmatex">\(∃xP( x)\)</span>.  </p>
<ul>
<li>Assume no <span class="arithmatex">\(c\)</span> exists which makes <span class="arithmatex">\(P(c)\)</span> true and derive a  contradiction </li>
</ul>
<h4 id="唯一性证明-uniqueness-proofs">唯一性证明 Uniqueness Proofs<a class="headerlink" href="#唯一性证明-uniqueness-proofs" title="Permanent link">&para;</a></h4>
<p>To show that a theorem assert the existence of a unique element with  a particular property. </p>
<p><span class="arithmatex">\(∃x( P(x) ∧ ∀ y ( y≠ x→¬P(y) ) )\)</span> </p>
<ul>
<li>Existence（存在性）: We show that an element x with the desired  property exists. </li>
<li>Uniqueness（唯一性） : We show that if <span class="arithmatex">\(y≠x\)</span>, then y does not have the  desired property. Or, we can show that if <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(y\)</span> both have the  desired property ,then <span class="arithmatex">\(x=y\)</span>.</li>
</ul>
<h4 id="反例证明-disproof-by-counterexample">反例证明 Disproof by Counterexample<a class="headerlink" href="#反例证明-disproof-by-counterexample" title="Permanent link">&para;</a></h4>
<p>Using the method of <strong>disproof by counterexample</strong> to establish that <span class="arithmatex">\(¬∀xP(x)\)</span> is true.  </p>
<ul>
<li>To construct a <span class="arithmatex">\(c\)</span> such that <span class="arithmatex">\(P(c)\)</span> is false. </li>
<li>Recall:    <span class="arithmatex">\(¬∀xP(x ) ⇔ ∃x¬ P(x)\)</span></li>
</ul>
<h4 id="nonexistence-proofs">Nonexistence Proofs<a class="headerlink" href="#nonexistence-proofs" title="Permanent link">&para;</a></h4>
<p>To establish that <span class="arithmatex">\(¬∃xP( x)\)</span> is true .  </p>
<ul>
<li>Use a proof by contradiction by assuming there is a <span class="arithmatex">\(c\)</span> which makes <span class="arithmatex">\(P(c)\)</span> true . </li>
<li>Recall: <span class="arithmatex">\(¬ ∃x P(x) ⇔ ∀ x ¬ P(x )\)</span></li>
</ul>
<h3 id="2-proof-strategy">2. Proof Strategy<a class="headerlink" href="#2-proof-strategy" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Forward reasoning</strong>: Using premises, together with axioms and known theorems to lead to the conclusion.  </li>
<li><strong>Backward reasoning</strong>: To reason backward to prove a statement q, we find a statement p that we can prove with the property that <span class="arithmatex">\(p→q\)</span>.</li>
</ul>
<h1 id="ch2-basic-structures">Ch2 Basic Structures<a class="headerlink" href="#ch2-basic-structures" title="Permanent link">&para;</a></h1>
<h2 id="21-sets">2.1 Sets<a class="headerlink" href="#21-sets" title="Permanent link">&para;</a></h2>
<p>【Definition】A <strong>set</strong> is an unordered collection of objects. The objects in a set are called the elements, or members, of the set. A set is said to contain its elements.</p>
<h3 id="1-the-descriptions-of-a-set">1. The descriptions of a set<a class="headerlink" href="#1-the-descriptions-of-a-set" title="Permanent link">&para;</a></h3>
<ul>
<li><u>Roster method 花名册方法</u> : listing all its members between braces, e.g. <span class="arithmatex">\(S=\{1,3,5,7,9\}\)</span></li>
<li><u>Brace notation with ellipses</u> : e.g. <span class="arithmatex">\(S=\{1,2,…,99\}\)</span></li>
<li><u>Use set builder notation 集合构造器 (specification by predicates)</u> : <span class="arithmatex">\(S=\{{x∣P(x)}\}\)</span>, which means <span class="arithmatex">\(S\)</span> contains all the elements from <span class="arithmatex">\(U\)</span> (<strong>全集 universal set</strong>) which have the property <span class="arithmatex">\(P\)</span>.</li>
<li><strong>维恩图(Venn diagrams)</strong></li>
</ul>
<h3 id="2-relations-between-sets">2. Relations between Sets<a class="headerlink" href="#2-relations-between-sets" title="Permanent link">&para;</a></h3>
<h4 id="subset">Subset<a class="headerlink" href="#subset" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A⊆B\)</span>: <span class="arithmatex">\(A\)</span> is a 子集(subset) of the set <span class="arithmatex">\(B\)</span>,  every element of <span class="arithmatex">\(A\)</span> is also an element of <span class="arithmatex">\(B\)</span>.</p>
<p><span class="arithmatex">\(A⊆B⇔∀x(x∈A→x∈B)\)</span></p>
<h4 id="equal">Equal<a class="headerlink" href="#equal" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A=B\)</span>: <span class="arithmatex">\(A\)</span> is <strong>等于(equal)</strong> to <span class="arithmatex">\(B\)</span>.</p>
<p>$A=B⇔A⊆B∧B⊆A⇔∀x[(x ∈A→ x ∈B) ∧ (x ∈B→ x ∈A)] $</p>
<h4 id="proper-subset">Proper Subset<a class="headerlink" href="#proper-subset" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A⊂B\)</span>: <span class="arithmatex">\(A\)</span> is a <strong>真子集(proper subset)</strong> of the set <span class="arithmatex">\(B\)</span>.</p>
<p><span class="arithmatex">\(A⊂B⇔A⊆B∧A≠B⇔∀x(x∈A→x∈B)∧∃(x∈B∧x∉A)\)</span></p>
<h4 id="the-size-of-a-set">The Size of a Set<a class="headerlink" href="#the-size-of-a-set" title="Permanent link">&para;</a></h4>
<p>【Definition】Let S be a set. If there are exactly <strong>n</strong> distinct elements in <span class="arithmatex">\(S\)</span> where <span class="arithmatex">\(n\)</span> is a nonnegative integer, we say that <span class="arithmatex">\(S\)</span> is a finite set and that <strong>n</strong> is the <strong>cardinality（基数）</strong>of <span class="arithmatex">\(S\)</span>.</p>
<ul>
<li>Notation:  <span class="arithmatex">\(∣S∣\)</span>—— S的<strong>基数</strong> the <strong>cardinality</strong> of <span class="arithmatex">\(S\)</span></li>
</ul>
<h4 id="power-sets">Power Sets<a class="headerlink" href="#power-sets" title="Permanent link">&para;</a></h4>
<p>Given a set <span class="arithmatex">\(S\)</span>, the <strong>幂集(power set)</strong> of <span class="arithmatex">\(S\)</span> is the set of <strong>all subsets</strong> of the set <span class="arithmatex">\(S\)</span>. <strong>$P(x) $</strong> denotes the power set of <span class="arithmatex">\(S\)</span>.</p>
<p>Example : If <span class="arithmatex">\(S=\{a,b,c\}\)</span>, then <span class="arithmatex">\(P(S)=\{\empty,\{a\},\{b\},\{c\},\{a,b\},\{a,c\},\{b,c\},\{a,b,c\}\}\)</span></p>
<h4 id="cartesian-products">Cartesian Products<a class="headerlink" href="#cartesian-products" title="Permanent link">&para;</a></h4>
<p><strong>[Definition]</strong> The <strong>有序 n 元组(ordered <span class="arithmatex">\(n-tuple\)</span>)</strong> (<span class="arithmatex">\(a_{1},a_{2},\dots,a_{n}\)</span>) is the ordered collection that has <span class="arithmatex">\(a_{1}\)</span> as its first element,  as its second <span class="arithmatex">\(a_{2}\)</span> element, … , and <span class="arithmatex">\(a_{n}\)</span> as its <span class="arithmatex">\(n_{th}\)</span> element. In particular, <span class="arithmatex">\(2-tuples\)</span> are called <strong>ordered pairs</strong>.</p>
<p>The Cartesian product of <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span>: <span class="arithmatex">\(A \times B = \{(a, b)| a \in A, b \in B\}\)</span></p>
<p>The Cartesian product of <span class="arithmatex">\(A_1 , A_2 , … , A_n\)</span> : <span class="arithmatex">\(A_{1}×A_{2}×\dots A_{n}\)</span>={<span class="arithmatex">\((a_{1},a_{2},\dots,a_{n})∣a_{i}∈A_{i}\)</span>, for <span class="arithmatex">\(i = 1,2,\dots ,n\)</span>}</p>
<h4 id="using-set-notation-with-quantifiers">Using Set Notation with Quantifiers<a class="headerlink" href="#using-set-notation-with-quantifiers" title="Permanent link">&para;</a></h4>
<p>Restrict the domain of a quantified statement explicitly by making use of a particular notation. </p>
<ul>
<li>$∀x∈S(P (x)):   ∀x(x∈S → p(x))   $     </li>
<li>$∃x∈S(P (x)):    ∃ x(x∈S ∧ p(x)) $</li>
</ul>
<h4 id="truth-sets-of-quantifiers">Truth Sets of Quantifiers<a class="headerlink" href="#truth-sets-of-quantifiers" title="Permanent link">&para;</a></h4>
<p>Given a predicate P and a domain <span class="arithmatex">\(D\)</span>. </p>
<p>The <strong>真集(truth set)</strong> of <span class="arithmatex">\(P\)</span> is the set of elements <span class="arithmatex">\(x\)</span> in <span class="arithmatex">\(D\)</span> for which <span class="arithmatex">\(P(x)\)</span> is true. Namely, the power set of <span class="arithmatex">\(P\)</span> is {<span class="arithmatex">\(x∈D∣P(x)\)</span>}</p>
<h2 id="22-set-operations">2.2  Set Operations<a class="headerlink" href="#22-set-operations" title="Permanent link">&para;</a></h2>
<h4 id="union">Union<a class="headerlink" href="#union" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A∪B=\)</span>{<span class="arithmatex">\(x∣x∈A∨x∈B\)</span>}</p>
<h4 id="intersection">Intersection<a class="headerlink" href="#intersection" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A∩B=\)</span>{<span class="arithmatex">\(x∣x∈A∧x∈B\)</span>}</p>
<p>Note : Two sets are called disjoint if their intersection is the empty set,namely $A∩B = Ø $</p>
<h4 id="complement">Complement<a class="headerlink" href="#complement" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(\overline A=\{{x∣x∉A, x∈U}\}\)</span> is the <strong>补集(complement)</strong> of the set A.</p>
<p>Let <span class="arithmatex">\(U\)</span> be universal set. The complement of the set <span class="arithmatex">\(A\)</span>  denoted by <span class="arithmatex">\(\overline A\)</span>, is <strong>the complement of <span class="arithmatex">\(A\)</span>with respect to <span class="arithmatex">\(U\)</span></strong>, namely, <span class="arithmatex">\(U – A\)</span>. (The complement of <span class="arithmatex">\(A\)</span> is sometimes denoted by <span class="arithmatex">\(A^{c}\)</span> .)</p>
<h4 id="difference">Difference<a class="headerlink" href="#difference" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A−B=\{{x∣x∈A∧x∉B}\}\)</span> </p>
<p>the set containing those elements that are <u>in A but not in B</u>.</p>
<h4 id="symmetric-difference">Symmetric difference<a class="headerlink" href="#symmetric-difference" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(A⊕B=(A∪B)−(A∩B)\)</span></p>
<p>the set containing those elements that are in <u>A but not in B</u> or <u>in B but not in A</u>.</p>
<h4 id="the-cardinality-of-a-union-of-two-sets">The Cardinality of a Union of Two Sets<a class="headerlink" href="#the-cardinality-of-a-union-of-two-sets" title="Permanent link">&para;</a></h4>
<p>The principle of Inclusion - exclusion <strong>容斥原理</strong>：$ |A \cup B| = |A| + |B| - |A \cap B|  $</p>
<h4 id="集合恒等式-set-identities">集合恒等式 Set Identities<a class="headerlink" href="#集合恒等式-set-identities" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th style="text-align: left;">Identity</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$ A \cup \emptyset = A, A \cap U = A $</td>
<td>Identity laws</td>
</tr>
<tr>
<td style="text-align: left;">$A \cup U = U, A \cap \emptyset = \emptyset $</td>
<td>Domination laws</td>
</tr>
<tr>
<td style="text-align: left;">$ A \cup A = A, A \cap A = A $</td>
<td>Idempotent laws</td>
</tr>
<tr>
<td style="text-align: left;">$ \overline{\overline{A}} = A $</td>
<td>Complementation law</td>
</tr>
<tr>
<td style="text-align: left;">$ A \cup B = B \cup A, A \cap B = B \cap A $</td>
<td>Commutative laws</td>
</tr>
<tr>
<td style="text-align: left;">$ A \cup (B \cup C) = (A \cup B) \cup C $</td>
<td>Associative laws</td>
</tr>
<tr>
<td style="text-align: left;">$A \cap (B \cap C) = (A \cap B) \cap C $</td>
<td></td>
</tr>
<tr>
<td style="text-align: left;">$ A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$</td>
<td>Distributive laws</td>
</tr>
<tr>
<td style="text-align: left;">$ A \cup (B \cap C) = (A \cup B) \cap (A \cup C) $</td>
<td></td>
</tr>
<tr>
<td style="text-align: left;">$ \overline{A \cup B} = \overline{A} \cap \overline{B} $</td>
<td>De Morgan’s laws</td>
</tr>
<tr>
<td style="text-align: left;">$ \overline{A \cap B} = \overline{A} \cup \overline{B} $</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="23-functions">2.3 Functions<a class="headerlink" href="#23-functions" title="Permanent link">&para;</a></h2>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : Let A and B be nonempty sets. A function <span class="arithmatex">\(f\)</span> from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span> is an assignment of each element of <span class="arithmatex">\(A\)</span> to exactly one element of <span class="arithmatex">\(B\)</span>.</p>
<p><strong>Denode</strong>: <span class="arithmatex">\(f:A→B\)</span>   or   <span class="arithmatex">\(∀a(a∈A→∃!b(b∈B∧f(a)=b))\)</span></p>
<ul>
<li>We write <span class="arithmatex">\(f(a) = b\)</span> if b is the unique element of B assigned by the  function f to the element a of A.  Functions are sometimes called <strong>mappings（映射）</strong> or <strong>transformations（变换）</strong>.</li>
</ul>
<p><strong>Given a function <span class="arithmatex">\(f: A → B\)</span>:</strong> </p>
<p><span class="arithmatex">\(f\)</span> maps <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span> or <span class="arithmatex">\(f\)</span> is a mapping from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span>.</p>
<ul>
<li>A is called the domain of <span class="arithmatex">\(f\)</span>, B is called the codomain of <span class="arithmatex">\(f\)</span>.</li>
<li>If <span class="arithmatex">\(f(a) = b\)</span>, then b is called the <strong>image(像)</strong> of a under <span class="arithmatex">\(f\)</span>, a is called the <strong>preimage(原像)</strong> of b.T</li>
<li>The range of <span class="arithmatex">\(f\)</span> is the set of <u>all images of points in <span class="arithmatex">\(A\)</span> under <span class="arithmatex">\(f\)</span></u>. We denote it by <span class="arithmatex">\(f(A)\)</span>.</li>
<li>Two functions are <strong>equal</strong> when they have the same domain, the same codomain and map each element of the domain to the same element of the codomain.</li>
</ul>
<p>【Definition】Let  <span class="arithmatex">\(f_{1}\)</span> and <span class="arithmatex">\(f_{2}\)</span> be functions from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(R\)</span>. Then $ (f_{1} + f_{2})(x) = f_{1}(x)+ f_{2}(x)$   $ (f_{1}f_{2})(x) = f_{1}(x) f_{2}(x)$ </p>
<p>【Definition】 Let <span class="arithmatex">\(f\)</span> be a function from A to B and let <span class="arithmatex">\(S\)</span> be a subset of A. The  image of <span class="arithmatex">\(S\)</span>  is the subset of B that consists of the images of the elements of S. We denote the image of <span class="arithmatex">\(S\)</span> by <span class="arithmatex">\(f(S)\)</span>, so that <span class="arithmatex">\(f (S) = \{{ f(s) | s∈S }\}\)</span></p>
<h3 id="one-to-one-functions">One-to-one Functions<a class="headerlink" href="#one-to-one-functions" title="Permanent link">&para;</a></h3>
<p>A function f is <strong>单射函数(one-to-one function / injection)</strong> , or <strong>单射的(injective)</strong> if</p>
<p><span class="arithmatex">\(∀a∀b(f(a)=f(b)→a=b)\)</span> </p>
<h3 id="onto-functions">Onto Functions<a class="headerlink" href="#onto-functions" title="Permanent link">&para;</a></h3>
<p>A function f from A to B is called <strong>满射函数(onto function / surjection)</strong>, or <strong>满射的(surjective)</strong> if</p>
<p><span class="arithmatex">\(∀b∈B∃a∈A(f(a)=b)\)</span></p>
<h3 id="one-to-one-correspondence-functions">One-to-one Correspondence Functions<a class="headerlink" href="#one-to-one-correspondence-functions" title="Permanent link">&para;</a></h3>
<p>The function f is a <strong>one-to-one correspondence</strong>, or a <strong>bijection</strong>(双射), if it is both <strong>one-to-one</strong> and <strong>onto</strong>.</p>
<blockquote>
<p><img alt="image-20250615162038356" src="images/image-20250615162038356.png" /></p>
</blockquote>
<h3 id="inverse-functions">Inverse Functions<a class="headerlink" href="#inverse-functions" title="Permanent link">&para;</a></h3>
<p>Let <span class="arithmatex">\(f\)</span> be a bijection from A to B. Then the inverse function of <span class="arithmatex">\(f\)</span>, denoted <span class="arithmatex">\(f ^{-1}\)</span>,  is the function from B to A defined as <span class="arithmatex">\(f  ^{-1} ( b ) = a\)</span> iff <span class="arithmatex">\(f ( a ) = b\)</span></p>
<h3 id="floor-and-ceiling-function">Floor and Ceiling Function<a class="headerlink" href="#floor-and-ceiling-function" title="Permanent link">&para;</a></h3>
<p>The ceiling function <span class="arithmatex">\(f (x)\)</span> is the smallest integer greater than or equal to x</p>
<p>The floor function <span class="arithmatex">\(f (x)\)</span> is the biggest integer smaller than or equal to x</p>
<h2 id="24-sequences-and-summations">2.4 Sequences and Summations<a class="headerlink" href="#24-sequences-and-summations" title="Permanent link">&para;</a></h2>
<h3 id="1-introduction_1">1. Introduction<a class="headerlink" href="#1-introduction_1" title="Permanent link">&para;</a></h3>
<p>[Definiton] A <strong>数列(sequence)</strong> is a function from a subset of the set of integers (usually either the set {0,1,2,…} or the set {1,2,3,…} ) to a set S. We use the notation <span class="arithmatex">\(a_{n}\)</span> to denote the image of the integer n. We call <span class="arithmatex">\(a_{n}\)</span> a <strong>term(项)</strong> of the sequence.</p>
<h3 id="2-some-familiar-sequences">2. Some Familiar Sequences<a class="headerlink" href="#2-some-familiar-sequences" title="Permanent link">&para;</a></h3>
<p>A <strong>等比数列(geometric progression)</strong> is a sequence of the form<span class="arithmatex">\(a, ar, ar^{2}, …, ar^{n}\)</span></p>
<p>where the initial term a and the <strong>公比(common ratio)</strong> r are real numbers.</p>
<p>An <strong>等差数列(arithmetic progression)</strong> is a sequence of the form<span class="arithmatex">\(a, a+d, a+2d …, a+nd\)</span></p>
<p>where the initial term a and the <strong>公差(common difference)</strong> d are real numbers.</p>
<h3 id="3-strings">3. Strings<a class="headerlink" href="#3-strings" title="Permanent link">&para;</a></h3>
<p>[Definition] A string is a finite sequence of characters from a finite set (an  alphabet).</p>
<h3 id="4-recurrence-relations">4. Recurrence Relations<a class="headerlink" href="#4-recurrence-relations" title="Permanent link">&para;</a></h3>
<p>[Definition] A <strong>recurrence relation(迭代关系)</strong> for the sequence <span class="arithmatex">\(\{a_{n}\}\)</span> is an equation that expresses an in terms of one or more of the previous terms of the  sequence, namely, <span class="arithmatex">\(a_{0}, a_{1}, …, a_{n-1}\)</span>, for all integers n with <span class="arithmatex">\(n ≥ n_{0}\)</span>, where <span class="arithmatex">\(n_{0}\)</span>  is a nonnegative integer.  </p>
<ul>
<li>A sequence is called a solution of a recurrence relation if its terms  satisfy the recurrence relation. </li>
<li>The initial conditions for a sequence specify the terms that precede the  first term where the recurrence relation takes effect. </li>
</ul>
<h2 id="25-cardinality-of-sets">2.5 Cardinality of Sets<a class="headerlink" href="#25-cardinality-of-sets" title="Permanent link">&para;</a></h2>
<ul>
<li>【Definition】: The sets <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span> have the same cardinality (denoted by <span class="arithmatex">\(| A |
  = | B |\)</span>) iff there exists a <u>one-to-one correspondence (bijection双射)</u> from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span></li>
<li>
<p>This provides a <strong>relative measure</strong> of the sizes of two sets, rather than a measure of the size of one particular set.</p>
</li>
<li>
<p>【Definition】: If there is a <u>one-to-one function单射</u> form <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span>, the cardinality of <span class="arithmatex">\(A\)</span> is less than or the same as cardinality of B (<span class="arithmatex">\(|A|≤|B|\)</span>). When <span class="arithmatex">\(|A|≤|B|\)</span> and <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span> have different cardinality, we say that the cardinality of <span class="arithmatex">\(A\)</span> is less than the cardinality of B and we write <span class="arithmatex">\(|A|&lt;|B|\)</span></p>
</li>
</ul>
<h3 id="1-countable-sets">1. Countable Sets<a class="headerlink" href="#1-countable-sets" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>【Definition】: A set that is either finite or has the same cardinality as <u>the set of positive integers</u> is called <strong>countable可数</strong></p>
</li>
<li>
<p>When an infinite set is countable (countably infinite) , its cardinality is <strong><span class="arithmatex">\(ℵ_{0}\)</span></strong> (where <span class="arithmatex">\(ℵ\)</span> is aleph, the 1st letter of the Hebrew alphabet). We write <em><span class="arithmatex">\(|S| = ℵ_{0}\)</span></em> and say that S has cardinality <strong><em>“ aleph null 阿列夫零 ”</em></strong></p>
</li>
<li>
<p>An infinite set is <strong>countable</strong> if and only if it is possible to <strong>list the elements of the set in a sequence</strong> (indexed by the positive integers, be expressed in terms of a sequence $a_{1},a_{2},\dots, a_{n} ,\dots $where $a_{1}=f(1),a_{2}=f(2),\dots, a_{n} =f(n),\dots $</p>
</li>
<li>
<p>正有理数集<span class="arithmatex">\(Q_{+}\)</span>是可数的</p>
</li>
<li>
<p>0 到 1 之间的实数集不可数</p>
</li>
<li><span class="arithmatex">\([1,2]\)</span>和<span class="arithmatex">\((1,2)\)</span>等势</li>
<li><span class="arithmatex">\(N\)</span>的有限子集都可数</li>
</ul>
<h3 id="2-uncountable-sets">2. Uncountable Sets<a class="headerlink" href="#2-uncountable-sets" title="Permanent link">&para;</a></h3>
<blockquote>
<ul>
<li>If set <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span> is countable, then <span class="arithmatex">\(A\cup B\)</span> is countable.</li>
<li><strong>有限个</strong>可数集合的交集是可数的</li>
</ul>
</blockquote>
<p>【Theorem】The set of real numbers between <span class="arithmatex">\(0\)</span> and <span class="arithmatex">\(1\)</span> is <strong>uncountable</strong>.</p>
<ul>
<li>use an important proof method known as the <strong>Cantor diagonalization argument</strong>（Cantor 对角化论证）</li>
</ul>
<p>【Theorem】The set of real numbers is <strong>uncountable</strong>.</p>
<ul>
<li>Any set with an uncountable subset is uncountable.</li>
<li><span class="arithmatex">\(|R|= ℵ\)</span></li>
<li>It is said to have the cardinality of the continuum, c.</li>
</ul>
<h3 id="3-results-about-cardinality">3. Results about cardinality<a class="headerlink" href="#3-results-about-cardinality" title="Permanent link">&para;</a></h3>
<p>1) No infinite set has a smaller cardinality than a countable set.
2) If A and B are countable, <span class="arithmatex">\(A\cup B\)</span> is countable.
3) The union of finite number of countable sets is countable.
4) The union of a countable number of countable sets is countable</p>
<h3 id="4-uncomputable-function">4. Uncomputable Function<a class="headerlink" href="#4-uncomputable-function" title="Permanent link">&para;</a></h3>
<p>【Definition】A function is <strong>computable</strong> if there is a computer program in some programming language that finds the values of this function. If a function is not computable, we say it is <strong>uncomputable</strong>.</p>
<h3 id="5-the-continum-hypothesis">5. The Continum Hypothesis<a class="headerlink" href="#5-the-continum-hypothesis" title="Permanent link">&para;</a></h3>
<ul>
<li>康托定理（Cantor's Theorem）The cardinality of the power set of an arbitrary set has a greater cardinality than the original arbitrary set. ( <span class="arithmatex">\(∣P(ℵ_{k})∣=∣ℵ_{k+1}∣\)</span> )</li>
<li>The power set of <span class="arithmatex">\(Z^{+}\)</span> and the set of real numbers <span class="arithmatex">\(R\)</span> have the  same cardinality. <span class="arithmatex">\(|P(Z^{+})|=|R|= c\)</span></li>
<li>The continuum hypothesis asserts that there is <strong>no cardinal number</strong> a such that  <span class="arithmatex">\(ℵ_{0} &lt; a &lt;  c\)</span>.</li>
</ul>
<h1 id="ch3-algorithm">Ch3 Algorithm<a class="headerlink" href="#ch3-algorithm" title="Permanent link">&para;</a></h1>
<h2 id="31-算法-algorithms">3.1 算法 Algorithms<a class="headerlink" href="#31-算法-algorithms" title="Permanent link">&para;</a></h2>
<p>[Definition] : An <strong>algorithm</strong> is a finite set of precise instructions for  performing a computation or for solving a problem.</p>
<h3 id="算法的性质-properties-of-algorithms">算法的性质 Properties of Algorithms<a class="headerlink" href="#算法的性质-properties-of-algorithms" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>输入(input)</strong>：An algorithm has input values from a specified set.</li>
<li><strong>输出(output)</strong>：From each set of input values, an algorithm produces output values from a specified set.</li>
<li><strong>确定性(definiteness)</strong>：算法的每一步都应该被精确定义。The steps of an algorithm must be defined precisely.</li>
<li><strong>正确性(correctness)</strong>：算法应该给出正确的输出结果。An algorithm should produce the correct output values for each set of input values.</li>
<li><strong>有限性(finiteness)</strong>：算法应当在有限步内结束。An algorithm should produce the desired output after a finite number of steps for any input in the set.</li>
<li><strong>有效性(effectiveness)</strong>：算法的每一步都可以被有效执行。Each step of an algorithm must be executed exactly and in a finite amount of time.</li>
<li><strong>通用性(generality)</strong>：我们的算法应该对于任意符合条件的输入都应用，而不是只适用某些特定的输入。The procedure should be applicable for all problems of the desired form, not just for a particular set of input values.</li>
</ul>
<h2 id="32-函数的增长-the-growth-of-functions">3.2 函数的增长 The Growth of Functions<a class="headerlink" href="#32-函数的增长-the-growth-of-functions" title="Permanent link">&para;</a></h2>
<h4 id="记号-notations">记号 Notations<a class="headerlink" href="#记号-notations" title="Permanent link">&para;</a></h4>
<p><strong>大 O 记号(<mark>Big-O notation</mark>)</strong>：Let <span class="arithmatex">\(f\)</span> and <span class="arithmatex">\(g\)</span> be functions from <span class="arithmatex">\(Z\)</span> (or <span class="arithmatex">\(R\)</span>) to <span class="arithmatex">\(R\)</span>. We say that “<span class="arithmatex">\(f(x)\)</span> is <span class="arithmatex">\(O(g(x))\)</span>” if there are constants <span class="arithmatex">\(C\)</span> and <span class="arithmatex">\(k\)</span> such that <span class="arithmatex">\(∣f(x)∣≤C∣g(x)∣\)</span> whenever <span class="arithmatex">\(x&gt;k\)</span>.</p>
<p><strong>大Ω记号(<mark>Big-Omega notation</mark>)</strong>：Let <span class="arithmatex">\(f\)</span> and <span class="arithmatex">\(g\)</span> be functions from <span class="arithmatex">\(Z\)</span> (or <span class="arithmatex">\(R\)</span>) to <span class="arithmatex">\(R\)</span>. We say that “<span class="arithmatex">\(f(x)\)</span> is <span class="arithmatex">\(\Omega(g(x))\)</span>” if there are constants <span class="arithmatex">\(C\)</span> and <span class="arithmatex">\(k\)</span> such that <span class="arithmatex">\(∣f(x)∣\geq C∣g(x)∣\)</span> whenever <span class="arithmatex">\(x&gt;k\)</span>.</p>
<p><strong>大Θ记号(<mark>Big-Theta notation</mark>)</strong>：Let <span class="arithmatex">\(f\)</span> and <span class="arithmatex">\(g\)</span> be functions from <span class="arithmatex">\(Z\)</span> (or <span class="arithmatex">\(R\)</span>) to <span class="arithmatex">\(R\)</span>. We say that “<span class="arithmatex">\(f(x)\)</span> is <span class="arithmatex">\(\Theta(g(x))\)</span>” if “f<span class="arithmatex">\(f(x)\)</span> is <span class="arithmatex">\(\Omega(g(x))\)</span>” and “<span class="arithmatex">\(f(x)\)</span> is <span class="arithmatex">\(\Omega(g(x))\)</span>” , i.e., there are constants <span class="arithmatex">\(C_1,C_2\)</span> and <span class="arithmatex">\(k\)</span> such that <span class="arithmatex">\(0≤C_1g(x)≤f(x)≤C_2g(x)\)</span> whenever <span class="arithmatex">\(x&gt;k\)</span>.</p>
<h3 id="the-growth-of-combinations-of-functions">The Growth of Combinations of Functions<a class="headerlink" href="#the-growth-of-combinations-of-functions" title="Permanent link">&para;</a></h3>
<ul>
<li>If <span class="arithmatex">\(f_1(x)\)</span> is <span class="arithmatex">\(O(g_1(x))\)</span> and  <span class="arithmatex">\(f_2(x)\)</span> is <span class="arithmatex">\(O(g_2(x))\)</span>, then <span class="arithmatex">\((f_1 + f_2)(x)\)</span> is <span class="arithmatex">\(O(max(g_1(x),g_2(x)))\)</span>. </li>
<li>If  <span class="arithmatex">\(f_1 (x)\)</span> and <span class="arithmatex">\(f_2 (x)\)</span> are both <span class="arithmatex">\(O(g(x))\)</span>, then <span class="arithmatex">\(( f_1 + f_2 )(x)\)</span> is <span class="arithmatex">\(O(g(x))\)</span>.</li>
<li>If  <span class="arithmatex">\(f_1(x)\)</span> is <span class="arithmatex">\(O(g_1(x))\)</span> and <span class="arithmatex">\(f_2(x)\)</span> is <span class="arithmatex">\(O(g_2(x))\)</span>, then <span class="arithmatex">\((f_1f_2)(x)\)</span> is <span class="arithmatex">\(O(g_1(x)g_2(x))\)</span>.</li>
</ul>
<h2 id="33-算法的复杂度-complexity-of-algorithms">3.3 算法的复杂度 Complexity of Algorithms<a class="headerlink" href="#33-算法的复杂度-complexity-of-algorithms" title="Permanent link">&para;</a></h2>
<p><img src="images/image-20250324193656175.png" alt="image-20250324193656175" style="zoom:50%;" /></p>
<h1 id="ch4-the-number-theory-and-cryptography">Ch4 The Number Theory and Cryptography<a class="headerlink" href="#ch4-the-number-theory-and-cryptography" title="Permanent link">&para;</a></h1>
<h2 id="41-divisibility-and-modular-arithmetic">4.1 Divisibility and Modular Arithmetic<a class="headerlink" href="#41-divisibility-and-modular-arithmetic" title="Permanent link">&para;</a></h2>
<h3 id="1-division">1. Division<a class="headerlink" href="#1-division" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> ：If <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are integers with <span class="arithmatex">\(a \neq 0\)</span>, then <span class="arithmatex">\(a\)</span> divides <span class="arithmatex">\(b\)</span> if there exists an integer <span class="arithmatex">\(c\)</span> such that <span class="arithmatex">\(b=ac\)</span></p>
<ul>
<li>When <span class="arithmatex">\(a\)</span> divides <span class="arithmatex">\(b\)</span> we say that <span class="arithmatex">\(a\)</span> is a factor or divisor of <span class="arithmatex">\(b\)</span> and that <span class="arithmatex">\(b\)</span> is a multiple of <span class="arithmatex">\(a\)</span>.</li>
<li>The notation <span class="arithmatex">\(a | b\)</span> denotes that <span class="arithmatex">\(a\)</span> divides <span class="arithmatex">\(b\)</span>.</li>
<li>If <span class="arithmatex">\(a | b\)</span> , then <strong><span class="arithmatex">\(b/a\)</span></strong>  is an integer.</li>
<li>If <span class="arithmatex">\(a\)</span> does not divide <span class="arithmatex">\(b\)</span>, we write <span class="arithmatex">\(a ∤ b\)</span></li>
</ul>
<h4 id="properties-of-divisibility">Properties of Divisibility<a class="headerlink" href="#properties-of-divisibility" title="Permanent link">&para;</a></h4>
<p><strong>Theorem</strong>: Let a, b, and c be integers, where <span class="arithmatex">\(𝒂 ≠ 𝟎\)</span>.</p>
<ul>
<li>If <span class="arithmatex">\(𝑎 | 𝑏\)</span> and <span class="arithmatex">\(𝑎 | 𝑐\)</span> , then <span class="arithmatex">\(𝑎 | (𝑏 + 𝑐)\)</span></li>
<li>If <span class="arithmatex">\(𝑎 | 𝑏\)</span> , then <span class="arithmatex">\(𝑎 | 𝑏𝑐\)</span> for all integers <span class="arithmatex">\(c\)</span></li>
<li>If <span class="arithmatex">\(𝑎 | 𝑏\)</span> and <span class="arithmatex">\(𝑏 | 𝑐\)</span>, then <span class="arithmatex">\(𝑎 | 𝑐\)</span></li>
</ul>
<p><strong>Corollary</strong>: If a, b, and c be integers, where <span class="arithmatex">\(a \neq 0\)</span>, such that <span class="arithmatex">\(𝑎 | 𝑏\)</span> and <span class="arithmatex">\(𝑎 | c\)</span>, then <span class="arithmatex">\(𝑎 | m𝑏+nc\)</span> whenever m and n are integers.</p>
<h3 id="2-division-algorithm">2. Division Algorithm<a class="headerlink" href="#2-division-algorithm" title="Permanent link">&para;</a></h3>
<p>If <span class="arithmatex">\(a\)</span> is an integer and <span class="arithmatex">\(d\)</span> a positive integer, then there are unique integers <span class="arithmatex">\(q\)</span> and <span class="arithmatex">\(r\)</span>, with <span class="arithmatex">\(0 \leq r &lt; d\)</span>, such that <span class="arithmatex">\(a = dq + r\)</span></p>
<ul>
<li>d is called the <strong>divisor 除数</strong> </li>
<li>a is called the <strong>dividend 被除数</strong> </li>
<li>q is called the <strong>quotient 商</strong>  <strong><u>q = a div d</u></strong></li>
<li>r is called the <strong>remainder 余数(非负)</strong> <strong><u>r = a mod d</u></strong></li>
</ul>
<h3 id="3-congruence-relation">3. Congruence Relation<a class="headerlink" href="#3-congruence-relation" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : 若 <span class="arithmatex">\(a\)</span> 和 <span class="arithmatex">\(b\)</span> 为整数，<span class="arithmatex">\(m\)</span> 为正整数，当 m 能整除 <span class="arithmatex">\(a − b\)</span> 时，称 <span class="arithmatex">\(a\)</span> 与 <span class="arithmatex">\(b\)</span> 对模 <span class="arithmatex">\(m\)</span> 同余。</p>
<ul>
<li>The notation <span class="arithmatex">\(a ≡ b (mod\)</span>  <span class="arithmatex">\(m)\)</span> says that a is congruent to b modulo m.</li>
<li>If a is not congruent to b modulo m, we write <span class="arithmatex">\(a ≢ b (mod\)</span>  <span class="arithmatex">\(m)\)</span></li>
</ul>
<p><strong>Theorem</strong>: Let m be a positive integer. The integers a and b are congruent modulo m if and only if there is an integer k such that <span class="arithmatex">\(a = b+km\)</span></p>
<h4 id="31-congruences-of-sums-and-products">3.1 Congruences of Sums and Products<a class="headerlink" href="#31-congruences-of-sums-and-products" title="Permanent link">&para;</a></h4>
<p><strong>Theorem</strong>: Let m be a positive integer. If <span class="arithmatex">\(a ≡ b\pmod m\)</span> and <span class="arithmatex">\(c ≡ d \pmod m\)</span>, then <span class="arithmatex">\(a+c ≡ b+d\pmod m\)</span> and <span class="arithmatex">\(ac ≡ bd\pmod m\)</span></p>
<h4 id="32-algebraic-manipulation-of-congruences">3.2 Algebraic Manipulation of Congruences<a class="headerlink" href="#32-algebraic-manipulation-of-congruences" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>在同余式两边同时乘以一个整数后仍然同余</strong></li>
<li>
<p>If  $a \equiv b \pmod{m} $ holds then  <mark><span class="arithmatex">\(c \cdot a \equiv c \cdot b \pmod{m}\)</span></mark> , where $c $ is any integer</p>
</li>
<li>
<p><strong>在同余式两边同时加上一个整数后仍然同余</strong></p>
</li>
<li>
<p>If  $a \equiv b \pmod{m} $ holds then  <mark><span class="arithmatex">\(a+c \equiv b+c \pmod{m}\)</span></mark> , where $c $ is any integer</p>
</li>
<li>
<p><strong>在同余式两边同时除以一个整数后同余无法确定</strong></p>
</li>
</ul>
<p><strong>[Corollary]</strong> :</p>
<ul>
<li><mark><span class="arithmatex">\((a + b) \mod m = ((a \mod m) + (b \mod m)) \mod m\)</span></mark></li>
<li><mark><span class="arithmatex">\(ab \mod m = \left((a \mod m)(b \mod m)\right) \mod m\)</span>.</mark></li>
</ul>
<h3 id="4-arithmetic-modulo-m">4. Arithmetic Modulo m<a class="headerlink" href="#4-arithmetic-modulo-m" title="Permanent link">&para;</a></h3>
<p><strong>[Definitions]</strong> : Let <span class="arithmatex">\(Z_m\)</span> be the set of nonnegative integers less than <span class="arithmatex">\(m\)</span>: { <span class="arithmatex">\(0,1, \dots , m − 1\)</span> }</p>
<ul>
<li>The operation <strong>+m</strong> is defined as $a+ _mb = (a+b)\mod m $. This is <strong>addition modulo m</strong>.</li>
<li>The operation <strong>∙m</strong> is defined as $a ⋅ _mb = (a\cdot b)\mod m $. This is <strong>multiplication modulo m</strong>.</li>
<li>Using these operations is said to be doing <u><strong><em>arithmetic modulo m算术模 m</em></strong></u></li>
</ul>
<p>The operations <strong>+m</strong> and <strong>·m</strong> satisfy many of the same properties as ordinary addition and multiplication.</p>
<ul>
<li><strong>Closure 封闭性</strong></li>
</ul>
<p>If <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> belong to <span class="arithmatex">\(Z_m\)</span>, then <span class="arithmatex">\(a +_m b \in Z_m\)</span> and <span class="arithmatex">\(a ·_m b \in Z_m\)</span> .</p>
<ul>
<li><strong>Associativity 结合律</strong></li>
</ul>
<p>If <span class="arithmatex">\(a\)</span>, <span class="arithmatex">\(b\)</span>, and $c $ belong to <span class="arithmatex">\(Z_m\)</span>, </p>
<p>then <span class="arithmatex">\((a +_mb) + _m c = a +_m (b +_m c)\)</span> and <span class="arithmatex">\((a ·_m b) ·_m c = a ·_m (b ·_m c)\)</span>.</p>
<ul>
<li><strong>Commutativity 交换律</strong></li>
</ul>
<p>If a and b belong to <span class="arithmatex">\(Z_m\)</span>, </p>
<p>then <span class="arithmatex">\(a +_m b = b +_m a\)</span> and <span class="arithmatex">\(a ·_m b = b ·_m a\)</span>.</p>
<ul>
<li><strong>Identity elements 单位元</strong></li>
</ul>
<p>The elements 0 and 1 are identity elements for addition and multiplication modulo m, respectively. </p>
<p>If a belongs to <span class="arithmatex">\(Z_m\)</span>, </p>
<p>then <span class="arithmatex">\(a +_m 0 = a\)</span> and <span class="arithmatex">\(a ·_m 1 = a\)</span>.</p>
<ul>
<li><strong>Additive inverses 加法逆元</strong></li>
</ul>
<p>If <span class="arithmatex">\(𝑎 ≠ 0\)</span> belongs to <span class="arithmatex">\(𝑍_𝑚\)</span> ,</p>
<p>then <span class="arithmatex">\(𝑚 − 𝑎\)</span> is the additive inverse of <strong>a modulo m</strong> and 0 is its own additive inverse. </p>
<ul>
<li>
<p><span class="arithmatex">\(𝑎 + _𝑚 (𝑚 − 𝑎 ) = 0\)</span> and <span class="arithmatex">\(0 +_𝑚 0 = 0\)</span></p>
</li>
<li>
<p>Distributivity 分配律</p>
</li>
</ul>
<p>If a, b, and c belong to <span class="arithmatex">\(𝑍_𝑚\)</span> , </p>
<p>then <span class="arithmatex">\(𝑎 ·_𝑚 (𝑏 +_𝑚 𝑐) = (𝑎· _𝑚 𝑏) + _𝑚 (𝑎 +_𝑚 𝑐)\)</span> and <span class="arithmatex">\((𝑎 +_𝑚 𝑏) ·_𝑚 𝑐 = (𝑎 ·_𝑚 𝑐) +_𝑚 (𝑏·_𝑚 𝑐)\)</span></p>
<h2 id="43-primes-and-greatest-common-divisors">4.3 Primes and Greatest Common Divisors<a class="headerlink" href="#43-primes-and-greatest-common-divisors" title="Permanent link">&para;</a></h2>
<h3 id="1-primes">1. Primes<a class="headerlink" href="#1-primes" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : A positive integer p greater than 1 is called prime if the only positive factors of p are 1 and p. A positive integer that is greater than 1 and is not <strong>prime素数</strong> is called <strong>composite合数</strong></p>
<p><strong>Theorem</strong>: There are infinitely many primes. (Euclid) 素数的无限性</p>
<p><strong>[Definition]</strong> : Prime numbers of the form <span class="arithmatex">\(2^p − 1\)</span>, where <span class="arithmatex">\(p\)</span> is prime, are called <strong>Mersenne primes梅森数</strong></p>
<h3 id="2-the-fundamental-theorem-of-arithmetic">2. The Fundamental Theorem of Arithmetic<a class="headerlink" href="#2-the-fundamental-theorem-of-arithmetic" title="Permanent link">&para;</a></h3>
<p><strong>Theorem 1</strong>: Every positive integer greater than 1 can be written uniquely as a prime or as the product of two or more primes where the prime factors are written in order of nondecreasing size. </p>
<p><strong>Theorem 2</strong>: If n is a composite integer, then n has a prime divisor less than or equal to <span class="arithmatex">\(\sqrt n\)</span></p>
<p>若 n 为合数，则 n 必有一个质因数小于或等于<span class="arithmatex">\(\sqrt n\)</span></p>
<h3 id="3-the-sieve-of-eratosthenes">3. The Sieve of Eratosthenes<a class="headerlink" href="#3-the-sieve-of-eratosthenes" title="Permanent link">&para;</a></h3>
<p><strong><em>The Sieve of Eratosthenes</em></strong> can be used to find all primes not  exceeding a specified positive integer n.  </p>
<blockquote>
<p>方法：找出所有不超过 n 的质数，然后从小到大依次将它们的倍数 ( 不超过 n ) 删去，剩下的数就是不超过 n 的质数。</p>
</blockquote>
<ul>
<li>For example, <span class="arithmatex">\(n=100\)</span> Begin with the list of integers between 1 and 100. </li>
<li>① Delete all  the integers, other than 2, divisible by 2. </li>
<li>② Delete all the integers, other than 3, divisible by 3. </li>
<li>③ Next, delete all the integers, other than 5, divisible by 5. </li>
<li>④ Next, delete all the integers, other than 7, divisible by 7. </li>
<li>⑤ Since all the remaining integers  are not divisible by any of the previous integers, other than 1, the primes are: <span class="arithmatex">\(\{2,3,5,7,11,15,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97\}\)</span></li>
</ul>
<h3 id="4-素数的分布">4. 素数的分布<a class="headerlink" href="#4-素数的分布" title="Permanent link">&para;</a></h3>
<p><strong>Prime Number Theorem</strong>: The ratio of the number of primes not exceeding <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(x/lnx\)</span> approaches <span class="arithmatex">\(1\)</span> as <span class="arithmatex">\(x\)</span> grows without bound. 
$$
\lim_{x\rightarrow \infty}\frac{\pi(x)}{x/lnx}=1
$$</p>
<h3 id="5-greatest-common-divisor">5. Greatest Common Divisor<a class="headerlink" href="#5-greatest-common-divisor" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : Let <span class="arithmatex">\(a\)</span> and $ b$ be integers, not both zero. The largest integer d such that 𝒅 | 𝒂 and also 𝒅 | 𝒃 is called the greatest common divisor of <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span>. The greatest common divisor of a and b is denoted by <span class="arithmatex">\(gcd(a,b)\)</span></p>
<p><strong>[Definition]</strong> : The integers <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are <strong>relatively prime</strong> if their greatest common divisor is 1</p>
<h3 id="6-least-common-multiple">6. Least Common Multiple<a class="headerlink" href="#6-least-common-multiple" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : The least common multiple of the positive integers <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> is the smallest positive integer that is divisible by both a and b. It is denoted by <span class="arithmatex">\(lcm(a,b)\)</span></p>
<p><strong>[Theorem]</strong> : Let a and b be positive integers. Then <span class="arithmatex">\(𝑎𝑏 = gcd(𝑎, 𝑏) · 𝑙𝑐𝑚(𝑎, 𝑏)\)</span></p>
<h3 id="7-euclidean-algorithm">7. Euclidean Algorithm<a class="headerlink" href="#7-euclidean-algorithm" title="Permanent link">&para;</a></h3>
<p>The Euclidian algorithm is an efficient method for computing the greatest common divisor of two integers.</p>
<ul>
<li>let <span class="arithmatex">\(a=bq+r\)</span>, then <span class="arithmatex">\(gcd(a,b) = gcd(b,r)\)</span></li>
</ul>
<p><img src="images/image-20250326103806432.png" alt="image-20250326103806432" style="zoom: 80%;" /></p>
<h3 id="8-gcds-as-linear-combinations">8. gcds as Linear Combinations<a class="headerlink" href="#8-gcds-as-linear-combinations" title="Permanent link">&para;</a></h3>
<p><strong>裴蜀定理 Bézout’s Theorem</strong> : If a and b are positive integers, then there exist integers s and t such that <mark><span class="arithmatex">\(𝒈𝒄𝒅(𝒂, 𝒃) = 𝒔𝒂 + 𝒕𝒃\)</span></mark></p>
<p><strong>[Definition]</strong> : If a and b are positive integers, then integers <span class="arithmatex">\(s\)</span> and <span class="arithmatex">\(t\)</span> such that <span class="arithmatex">\(gcd(a,b) =sa+tb\)</span> are called <strong>Bézout coefficients 裴蜀系数</strong> of a and b. The equation  <span class="arithmatex">\(gcd(a,b) =sa+tb\)</span> is called <strong>Bézout’s identity 裴蜀恒等式</strong></p>
<ul>
<li>Lemma : If a, b, and c are positive integers such that <span class="arithmatex">\(gcd(a,b)=1\)</span> and 𝒂 |𝒃𝒄, then 𝒂 | 𝒄</li>
<li>Lemma : If p is prime and <span class="arithmatex">\(p | a_1 a_2 \dots a_n\)</span>, then <span class="arithmatex">\(p | a_i\)</span> for some i</li>
</ul>
<h3 id="9-dividing-congruences-by-an-integer">9. Dividing Congruences by an Integer<a class="headerlink" href="#9-dividing-congruences-by-an-integer" title="Permanent link">&para;</a></h3>
<p><strong>[Theorem]</strong> : Let m be a positive integer and let a, b, and c be integers.</p>
<p>If <span class="arithmatex">\(𝒂𝒄 ≡ 𝒃𝒄 \pmod 𝒎\)</span> and <span class="arithmatex">\(𝒈𝒄𝒅(𝒄, 𝒎) = 𝟏\)</span>, then <span class="arithmatex">\(𝒂 ≡ 𝒃 \pmod 𝒎\)</span></p>
<h2 id="44-solving-congruences">4.4 Solving Congruences<a class="headerlink" href="#44-solving-congruences" title="Permanent link">&para;</a></h2>
<h3 id="1-linear-congruences">1. Linear Congruences<a class="headerlink" href="#1-linear-congruences" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : A congruence of the form <span class="arithmatex">\(ax ≡ b \pmod m\)</span>, where m is <span class="arithmatex">\(a\)</span> positive integer, <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are integers, and <span class="arithmatex">\(x\)</span> is a variable, is called a linear congruence.</p>
<ul>
<li><em>The solutions to a linear congruence</em> <span class="arithmatex">\(ax ≡ b \pmod m\)</span> are all integers x that satisfy the congruence</li>
</ul>
<h3 id="2-inverse-of-a-modulo-m">2. Inverse of a modulo m<a class="headerlink" href="#2-inverse-of-a-modulo-m" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong>: An integer <span class="arithmatex">\(\overline{a}\)</span> such that <span class="arithmatex">\(\overline a a ≡ 1 \pmod m\)</span> is said to be <strong>an inverse of a modulo m</strong>.</p>
<p><strong>Theorem</strong> : 若<span class="arithmatex">\(a,m\)</span>互质并且<span class="arithmatex">\(m\geq1\)</span>，则<span class="arithmatex">\(a模m\)</span>的逆存在，且对模<span class="arithmatex">\(m\)</span>的逆是唯一的。</p>
<ul>
<li>The Euclidean algorithm and Bézout coefficients gives us a <strong>systematic approaches</strong> to finding inverses</li>
</ul>
<p>if <span class="arithmatex">\(sa+tm=1\)</span>, then <mark><span class="arithmatex">\(s a ≡ 1 \pmod m\)</span></mark>, <mark><span class="arithmatex">\(s=\overline{a}\)</span></mark></p>
<h3 id="3-the-chinese-remainder-theorem">3. The Chinese Remainder Theorem<a class="headerlink" href="#3-the-chinese-remainder-theorem" title="Permanent link">&para;</a></h3>
<div class="arithmatex">\[
x \equiv a_1 \pmod {m_1} \\
x \equiv a_2 \pmod {m_2} \\
\dots \\
x \equiv a_n \pmod {m_n}
\]</div>
<p><span class="arithmatex">\(gcd(m_i,m_j)=1(i \neq j)\)</span> and <span class="arithmatex">\(m_i &gt; 1\)</span></p>
<p>To construct a solution</p>
<ul>
<li>
<p>First let <span class="arithmatex">\(M_k = {m}/{m_k}\)</span> for $ k = 1, 2, ..., n$, where $m = m_1 m_2 \dots m_n $ .
  Since $\text{gcd}(m_k, M_k) = 1 $, there is an integer $ y_k $, an inverse of $M_k $ modulo $ m_k $, such that <span class="arithmatex">\(M_k y_k \equiv 1 \ (\text{mod} \ m_k)\)</span></p>
</li>
<li>
<p>Form the sum</p>
</li>
</ul>
<p><mark>$ x = a_1 M_1 y_1 + a_2 M_2 y_2 + \cdots + a_n M_n y_n$</mark></p>
<ul>
<li>
<p>Note that because $M_j \equiv 0  (\text{mod}  m_k) $ whenever $ j \neq k $, all terms except the <span class="arithmatex">\(k\)</span>th term in this sum are congruent to <span class="arithmatex">\(0\)</span> modulo $m_k $.</p>
</li>
<li>
<p>Because $M_k y_k \equiv 1  (\text{mod}  m_k) $, we see that $ x \equiv a_k M_k y_k \equiv a_k (\text{mod}  m_k) $, for $k = 1, 2, ..., n $.
  Hence, <span class="arithmatex">\(x\)</span>  is a simultaneous solution to the <span class="arithmatex">\(n\)</span> congruences.</p>
</li>
</ul>
<h4 id="反向替换-back-substitution">反向替换 Back Substitution<a class="headerlink" href="#反向替换-back-substitution" title="Permanent link">&para;</a></h4>
<ol>
<li>The first congruence can be rewritten as <span class="arithmatex">\(x = 5t +1\)</span>, where t is an integer</li>
<li>Substituting into the second congruence yields  <span class="arithmatex">\(5t +1 ≡ 2 (mod 6).\)</span> </li>
<li>Solving this tells us that  <span class="arithmatex">\(t ≡ 5 (mod 6)\)</span></li>
<li><span class="arithmatex">\(t = 6u + 5\)</span> where <span class="arithmatex">\(u\)</span> is an integer.  </li>
<li>Substituting this back into <span class="arithmatex">\(x = 5t +1\)</span>,  gives $ x = 5(6u + 5) +1 = 30u + 26$</li>
<li>Inserting this into the third equation gives <span class="arithmatex">\(30u + 26 ≡ 3 (mod 7)\)</span></li>
<li>Solving this congruence tells us that <span class="arithmatex">\(u ≡ 6 (mod 7)\)</span></li>
<li><span class="arithmatex">\(u = 7v + 6\)</span>, where <span class="arithmatex">\(v\)</span> is an integer</li>
<li>Substituting this expression for <span class="arithmatex">\(u\)</span> into <span class="arithmatex">\(x  =  30u + 26\)</span>, tells us that <span class="arithmatex">\(x  =  30(7v + 6) + 26 = 210v + 206\)</span></li>
<li>Translating this back into a congruence we find the solution <span class="arithmatex">\(x ≡ 206 (mod 210)\)</span></li>
</ol>
<h3 id="4-computer-arithmetic-with-large-integers">4. Computer Arithmetic with Large Integers<a class="headerlink" href="#4-computer-arithmetic-with-large-integers" title="Permanent link">&para;</a></h3>
<p>Suppose that <span class="arithmatex">\(m_1, m_2, \dots, m_n\)</span> are pairwise relatively prime moduli and let <span class="arithmatex">\(m\)</span> be their product.  By the Chinese remainder theorem, we can show that an integer <span class="arithmatex">\(a\)</span> with <span class="arithmatex">\(0 ≤ a &lt; m\)</span> can be  uniquely represented by the n-tuple consisting of its remainders upon division by <span class="arithmatex">\(m_i , i = 1,  2, … , n\)</span> That is, we can uniquely represent <span class="arithmatex">\(a\)</span> by <mark><span class="arithmatex">\((a \mod m_1, a \mod m_2, \dots , a \mod m_n)\)</span></mark></p>
<h3 id="5-fermats-little-theorem">5. Fermat’s Little Theorem<a class="headerlink" href="#5-fermats-little-theorem" title="Permanent link">&para;</a></h3>
<blockquote>
<p>如果 <span class="arithmatex">\(p\)</span> 是质数，<span class="arithmatex">\(a\)</span> 为整数，且 <span class="arithmatex">\(p∤a\)</span>，那么 <span class="arithmatex">\(a^p ≡ a \pmod p\)</span></p>
</blockquote>
<p><strong>[Theorem]</strong> : If <span class="arithmatex">\(p\)</span> is prime and <span class="arithmatex">\(a\)</span> is an integer not divisible by <span class="arithmatex">\(p\)</span>, then <span class="arithmatex">\(a^{p-1} ≡ 1 \pmod p\)</span> Furthermore, for every integer <span class="arithmatex">\(a\)</span> we have <mark><span class="arithmatex">\(a^p ≡ a \pmod p\)</span></mark></p>
<ul>
<li><strong>Note</strong>：To find an mod <span class="arithmatex">\(p\)</span>, we only need to compute <span class="arithmatex">\(a^r\)</span> mod <span class="arithmatex">\(p\)</span>, where <span class="arithmatex">\(n = q(p − 1) + r, 0 \leq r \leq p − 1\)</span></li>
</ul>
<h3 id="6-pseudoprimes">6. Pseudoprimes<a class="headerlink" href="#6-pseudoprimes" title="Permanent link">&para;</a></h3>
<ul>
<li>By Fermat’s little theorem <span class="arithmatex">\(n &gt; 2\)</span> is prime, where <span class="arithmatex">\(2^{n-1} ≡ 1 \pmod n\)</span>  </li>
<li>But if this congruence holds, <span class="arithmatex">\(n\)</span> may not be prime.</li>
</ul>
<p>Given a positive integer <span class="arithmatex">\(n\)</span>, such that  <span class="arithmatex">\(2^{n-1} ≡ 1 \pmod n\)</span>: </p>
<ul>
<li>If <span class="arithmatex">\(n\)</span> does not satisfy the congruence, it is <strong>composite合数</strong>.  </li>
<li>If <span class="arithmatex">\(n\)</span> does satisfy the congruence, it is either <strong>prime</strong> or <strong>pseudoprime</strong></li>
</ul>
<h3 id="7-carmichael-numbers">7. Carmichael  Numbers<a class="headerlink" href="#7-carmichael-numbers" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> : A composite integer <span class="arithmatex">\(n\)</span> that satisfies the congruence <span class="arithmatex">\(bn-1 ≡ 1 \pmod n\)</span> for all positive integers <span class="arithmatex">\(b\)</span> with <span class="arithmatex">\(gcd(b,n) = 1\)</span> is called a <mark>Carmichael number</mark></p>
<h1 id="ch5-induction-and-recursion">Ch5 Induction and Recursion<a class="headerlink" href="#ch5-induction-and-recursion" title="Permanent link">&para;</a></h1>
<h2 id="51-mathematical-induction">5.1 Mathematical Induction<a class="headerlink" href="#51-mathematical-induction" title="Permanent link">&para;</a></h2>
<h3 id="1-principle-of-mathematical-induction">1. Principle of Mathematical Induction<a class="headerlink" href="#1-principle-of-mathematical-induction" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>The (first) principle of Mathematical Induction</strong> </li>
</ul>
<p>$ (P(1) ∧∀ k(P(k) → P(k+1))) →∀ n P(n)$ where the domain is the set of positive integers</p>
<h3 id="2-the-procedure">2. The procedure<a class="headerlink" href="#2-the-procedure" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>Inductive base: Establish $P(k) $</p>
</li>
<li>
<p>Inductive step: Prove that <span class="arithmatex">\(P(n) → P(n+1)\)</span> for $n≥ k $</p>
</li>
</ol>
<p>Conclusion: The inductive base and the inductive step together imply <span class="arithmatex">\(P(n) ∀ n ≥ k\)</span></p>
<h2 id="52-strong-induction-and-well-ordering">5.2 Strong Induction and Well-ordering<a class="headerlink" href="#52-strong-induction-and-well-ordering" title="Permanent link">&para;</a></h2>
<h3 id="1-strong-induction">1. Strong Induction<a class="headerlink" href="#1-strong-induction" title="Permanent link">&para;</a></h3>
<ul>
<li>The Second Principle of Mathematical Induction<em>数学归纳法第二原理</em>  (<mark>Strong Induction</mark>,  complete induction) </li>
</ul>
<p><span class="arithmatex">\((P(n_0 )∧∀k ( k\geq n_0 ∧P(n_0 )∧P(n_0 +1)∧…∧P(k) →  P(k+1)))→ ∀n P(n)\)</span></p>
<p><strong>The procedure</strong> : </p>
<ol>
<li><em>BASIS STEP</em> : Establish <span class="arithmatex">\(P(n_0 )\)</span></li>
<li><em>INDUCTIVE STEP</em> : Prove <span class="arithmatex">\(P(n_0 )∧P(n_0 +1)∧ . . . ∧P(k) → P(k+1)\)</span> </li>
<li><em>CONCLUSION</em>: The inductive base and the inductive step allow one to conclude that <span class="arithmatex">\(P(n) \space ∀n≥n_0\)</span></li>
</ol>
<h3 id="2-using-strong-induction-in-computational-geometry">2. Using Strong Induction in Computational Geometry<a class="headerlink" href="#2-using-strong-induction-in-computational-geometry" title="Permanent link">&para;</a></h3>
<p><strong>Some terms</strong> :</p>
<ul>
<li><strong>多边形 (polygon)</strong>：由一系列线段 <span class="arithmatex">\(s_1,s_2,…,s_n\)</span>( 它们被称为<strong>边 (sides)</strong>) 构成的封闭几何图形</li>
<li><strong>顶点 (vertex)</strong>：多边形中每对连续的边 <span class="arithmatex">\(s_i,s_{i+1}(i=1,2,…,n−1)\)</span>上的公共端点</li>
<li>每个简单多边形将平面划分成 2 个区域：</li>
<li><strong>内部 (interior)</strong>：曲线内的所有点</li>
<li><strong>外部 (exterior)</strong>：曲线外的所有点</li>
<li><strong>凸 (convex)</strong>多边形：任意两个顶点间的线段位于多边形的内部或边界上。否则被称为<strong>凹 (nonconvex)</strong>多边形</li>
<li>对角线 (diagonal)：在简单多边形中，连接两个非连续顶点的线段</li>
<li><strong>内部对角线 (internal diagonal)</strong>：如果除了端点外完全在内部的对角线</li>
</ul>
<h3 id="3-well-ordering-property">3. Well-ordering property<a class="headerlink" href="#3-well-ordering-property" title="Permanent link">&para;</a></h3>
<ul>
<li>假设 <span class="arithmatex">\(r≥d\)</span>，因为 <span class="arithmatex">\(a=dq_0+r\)</span>，所以 <span class="arithmatex">\(a−d(q_0+1)=r−d≥0\)</span>，因此存在 <span class="arithmatex">\(q\)</span> 和 <span class="arithmatex">\(r\)</span>，使得 <span class="arithmatex">\(0≤r&lt;d\)</span> 成立（且 <span class="arithmatex">\(q\)</span> 和 <span class="arithmatex">\(r\)</span> 是唯一的）</li>
</ul>
<p><img src="images/image-20250409103839783.png" alt="image-20250409103839783" style="zoom:67%;" /></p>
<h2 id="53-recursive-definition-and-structural-induction">5.3 Recursive Definition and Structural Induction<a class="headerlink" href="#53-recursive-definition-and-structural-induction" title="Permanent link">&para;</a></h2>
<h3 id="1-recursively-defined-functions">1. Recursively defined functions<a class="headerlink" href="#1-recursively-defined-functions" title="Permanent link">&para;</a></h3>
<p><em>Recursively defined functions</em>, with <u>the set of nonnegative integers as its domain</u> :  </p>
<ul>
<li><strong>Basis Step</strong>: Specify the value of the function at zero.</li>
<li><strong>Recursive Step</strong>: Give the rules for finding its value at an integer from its value at smaller integers</li>
</ul>
<h3 id="2-the-complexity-of-euclidean-algorithm">2. The Complexity of Euclidean algorithm<a class="headerlink" href="#2-the-complexity-of-euclidean-algorithm" title="Permanent link">&para;</a></h3>
<p><strong>LAME’S Theorem</strong> Let <span class="arithmatex">\(a , b\)</span> be positive integers with <span class="arithmatex">\(a≥b\)</span>. Then the number of divisions used by the Euclidean algorithm to find <span class="arithmatex">\(gcd (a, b)\)</span> is less than or equal to <u>five times the number of decimal digits in b</u>.</p>
<p><img src="images/image-20250409135735686.png" alt="image-20250409135735686"  /></p>
<p>因为 b 的十进制位数为 <span class="arithmatex">\(⌊log⁡_{10}b⌋+1≤log⁡_{10}b+1\)</span>，由定理 1 知除法次数小于等于 <span class="arithmatex">\(5(log⁡_{10}b+1)\)</span>。又因为 <span class="arithmatex">\(5(log_{⁡10}b+1)\)</span> 是 <span class="arithmatex">\(O(log⁡b)\)</span>，因此可以得到上述结论。</p>
<h3 id="3-recursively-defined-sets-and-structures">3. Recursively Defined Sets and Structures<a class="headerlink" href="#3-recursively-defined-sets-and-structures" title="Permanent link">&para;</a></h3>
<p><strong>Sets can be defined recursively.</strong> </p>
<ul>
<li><strong><em>BASIS STEP</em></strong>: Specify an initial collection of elements. </li>
<li><strong><em>RECURSIVE STEP</em></strong>: Give the rules for constructing elements of the set from other  elements already in the set.</li>
</ul>
<p><strong>Strings can be defined recursively.</strong> </p>
<ul>
<li>
<p>来自字母表 <span class="arithmatex">\(Σ\)</span> 的字符串，是一个由来自 <span class="arithmatex">\(Σ\)</span> 的符号构成的有限序列。</p>
</li>
<li>
<p>来自字母表 <span class="arithmatex">\(Σ\)</span> 的字符串集合 <span class="arithmatex">\(Σ^∗\)</span>，按照下面步骤递归定义：</p>
</li>
<li>
<p><strong><em>BASIS STEP</em></strong>：<span class="arithmatex">\(λ∈Σ^∗\)</span>，<span class="arithmatex">\(λ\)</span> 是不包含符号的空字符串</p>
</li>
<li>
<p><strong><em>RECURSIVE STEP</em></strong>：如果<span class="arithmatex">\(w∈Σ^∗\)</span> 且 <span class="arithmatex">\(x∈Σ\)</span>，那么<span class="arithmatex">\(wx∈Σ^∗\)</span></p>
<blockquote>
<p>在递归步骤中，通过在原有字符串的末尾添加一个字符来形成新的字符串。</p>
</blockquote>
</li>
</ul>
<p><strong>String Concatenation</strong></p>
<blockquote>
<p><strong>[Definition]</strong>: Two strings can be combined via the operation of concatenation. Let <span class="arithmatex">\(Σ\)</span> be a set of symbols and <span class="arithmatex">\(Σ^*\)</span> be the set of strings formed from the symbols in <span class="arithmatex">\(Σ\)</span>. We can define the  concatenation of two strings, denoted by <strong>∙</strong>, recursively as follows. </p>
</blockquote>
<ul>
<li><strong><em>BASIS STEP</em></strong>: If <span class="arithmatex">\(w ∈ Σ^*\)</span>, then <span class="arithmatex">\(w ∙ λ= w\)</span></li>
<li><strong>RECURSIVE STEP</strong>: If  <span class="arithmatex">\(w_1 ∈ Σ^*\)</span> and <span class="arithmatex">\(w_2 ∈ Σ\)</span> and <span class="arithmatex">\(x ∈ Σ\)</span>, then <span class="arithmatex">\(w_1 ∙ (w_2 x)= (w_1 ∙w_2)x\)</span>.</li>
</ul>
<p>Another important use of recursive definitions is to define well-formed formulae of various types.</p>
<p><strong>Well-formed formulae for compound propositions</strong></p>
<blockquote>
<p><strong>[Definition]:</strong>  The set of well-formed formulae in propositional logic involving <strong>T</strong>, <strong>F</strong>, propositional variables and operators from the set {<span class="arithmatex">\(¬, ∧, ∨, →, ↔\)</span>}</p>
</blockquote>
<p><strong>Solution:</strong>  </p>
<ul>
<li><strong>Basis Step:</strong>  <strong><em>T</em>*, </strong>F<strong><em>, and </em></strong>p*** where p is a propositional variable, are well-formed formulae.</li>
<li><strong>Recursive Step:</strong>  <span class="arithmatex">\((¬p)，(p ∨ q)，(p ∧ q)，(p → q)，(p ↔ q)\)</span>, are well-formed formulae if p and q are well-formed formulae</li>
</ul>
<h3 id="4-structural-induction">4. Structural Induction<a class="headerlink" href="#4-structural-induction" title="Permanent link">&para;</a></h3>
<p><strong>A proof by structural induction 结构归纳法:</strong>  </p>
<ul>
<li><strong>Basis Step:</strong> Show that the result holds for all elements specified in the basis step of the recursive definition to be in the set.<br />
  <u>证明结果对于递归定义中基础步骤所指定的所有元素都成立，这些元素属于该集合。</u></li>
<li><strong>Recursive Step:</strong> Show that if the statement is true for each of the elements used to construct new elements in the recursive step of the definition, the result holds for these new elements.
  <u>证明如果该命题对于递归定义中用于构造新元素的每个元素都成立，那么结果对于这些新元素也成立。</u></li>
</ul>
<p><strong>The validity of structural induction</strong></p>
<p>令 <span class="arithmatex">\(P(n)\)</span> 表示：对于所有由 <span class="arithmatex">\(n\)</span> 次或更少次来自递归定义中递归步骤的规则应用而产生的元素，结果为真</p>
<ul>
<li><strong><em>BASIS STEP</em></strong>：证明 <span class="arithmatex">\(P(0)\)</span> 为真</li>
<li><strong><em>RECURSIVE STEP</em></strong>：假设 <span class="arithmatex">\(P(k)\)</span> 为真，那么 <span class="arithmatex">\(P(k+1)\)</span> 为真</li>
</ul>
<h3 id="5-generalized-induction">5. Generalized Induction<a class="headerlink" href="#5-generalized-induction" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Generalized induction 广义归纳法</strong> is used to prove results about sets other than the integers that  have the <strong>well-ordering property</strong>.</p>
</li>
<li>
<p>Consider an ordering on <span class="arithmatex">\(N ⨉ N\)</span>, ordered pairs of nonnegative integers.  Specify that <span class="arithmatex">\((x_1 ,y_1)\)</span> is less than or equal to <span class="arithmatex">\((x_2 ,y_2)\)</span> if either <span class="arithmatex">\(x_1 &lt; x_2\)</span>, or <span class="arithmatex">\(x_1 = x_2\)</span>  and <span class="arithmatex">\(y_1&lt;y_2\)</span> .  This is called the <strong><em>lexicographic ordering</em></strong> <strong><em>词典序</em></strong></p>
</li>
</ul>
<p><img alt="image-20250409140908979" src="images/image-20250409140908979.png" /></p>
<h2 id="54-recursive-algorithms">5.4 Recursive Algorithms<a class="headerlink" href="#54-recursive-algorithms" title="Permanent link">&para;</a></h2>
<ul>
<li>An algorithm is called <strong>recursive</strong> if it solves a problem by <u>reducing it to an instance of the same problem with smaller input</u>.</li>
</ul>
<h3 id="recursion-and-iteration">Recursion and Iteration<a class="headerlink" href="#recursion-and-iteration" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><em>Recursion 递归</em></strong> : Successively reducing the computation to the evaluation of the function an  smaller integers </li>
<li>
<p><strong><em>Iteration 迭代</em></strong> : Start with the value of the function at one or more integers, the base cases, and successively apply the recursive definition to find the value of the  function at successive large integers</p>
</li>
<li>
<p>对于每个递归算法，总有等价的迭代算法</p>
</li>
<li><strong>递归算法</strong>相比迭代算法，通常<em>更小、更优雅、更易于理解</em></li>
<li>然而，<strong>迭代算法</strong>在空间和时间上的效率往往高于递归算法</li>
</ul>
<h1 id="ch6-counting">Ch6 Counting<a class="headerlink" href="#ch6-counting" title="Permanent link">&para;</a></h1>
<h2 id="61-the-basics-of-counting">6.1 The Basics of Counting<a class="headerlink" href="#61-the-basics-of-counting" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>The Product Rule 乘积法则</strong> : Suppose that a procedure can be broken down into two tasks. If there are <span class="arithmatex">\(n_1\)</span> ways to do the first task and <span class="arithmatex">\(n_2\)</span> ways to do the second after the first task has been done, then there are <span class="arithmatex">\(n_1 n_2\)</span> ways to complete the procedure. </li>
</ul>
<p><strong><em>Product Rule in Terms of Sets</em></strong> : If <span class="arithmatex">\(A_1, A_2, … , A_m\)</span> ainite sets, then the number of elements in the Cartesian product of these sets is the product of the number of elements of each set</p>
<ul>
<li>
<p><span class="arithmatex">\(|A_1 ⨉ A_2 ⨉ \dots ⨉ A_m |= |A_1| \times |A_2| \times \dots\times|A_m|\)</span></p>
</li>
<li>
<p><strong>The Sum Rule 加法法则</strong> :  <span class="arithmatex">\(|A_1 ∪ A_2 ∪ \dots ∪ A_m |= |A_1| + |A_2| + \dots + |A_m| , when \space A_i ∩ A_j  = \empty \space for \space all \space i,\space j\)</span></p>
</li>
<li>
<p><strong>The Subtraction Rule 减法法则</strong> : 容斥原理(the inclusion-exclusion principle)If S and T are finite sets, then <span class="arithmatex">\(∣S∪T∣=∣S∣+∣T∣−∣S∩T∣\)</span></p>
</li>
<li>
<p><strong>The Division Rule 除法法则</strong> : There are <span class="arithmatex">\(n/d\)</span> ways to do a task if it can be done using a procedure that can be carried out in <span class="arithmatex">\(n\)</span> ways, and for every way <span class="arithmatex">\(w\)</span>, exactly <span class="arithmatex">\(d\)</span> of the <span class="arithmatex">\(n\)</span> ways correspond to way <span class="arithmatex">\(w\)</span>. </p>
</li>
<li>
<p><strong>Tree Diagrams</strong> : We can solve many counting problems through the use of tree diagrams, where a branch represents a possible choice and the leaves represent possible outcomes. </p>
</li>
</ul>
<h2 id="62-the-pigeonhole-principle">6.2 The Pigeonhole Principle<a class="headerlink" href="#62-the-pigeonhole-principle" title="Permanent link">&para;</a></h2>
<p>[ Theorem 1 ] <strong><em>The Pigeonhole Principle</em></strong> 
If <span class="arithmatex">\(k\)</span> is a positive integer and <span class="arithmatex">\(k+1\)</span> or more objects are placed into <span class="arithmatex">\(k\)</span> boxes, then there is at least one box containing two or more of the objects. </p>
<blockquote>
<p>鸽巢原理又被称为狄利克雷抽屉原理 (<em>Dirchlet drawer principle</em>)</p>
</blockquote>
<p><img alt="image" src="images/image.png" /></p>
<p>[Theorem 2] <strong><em>The Generalized Pigeonhole Principle</em></strong> 
If <span class="arithmatex">\(N\)</span> objects are placed into <span class="arithmatex">\(k\)</span> boxes, then there is at least one box containing at least <span class="arithmatex">\(⌈N/k⌉\)</span> objects.</p>
<h2 id="63-permutations-and-combinations">6.3 Permutations and Combinations<a class="headerlink" href="#63-permutations-and-combinations" title="Permanent link">&para;</a></h2>
<h3 id="1-permutation-排列">1. Permutation 排列<a class="headerlink" href="#1-permutation-排列" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><em>permutation</em></strong> : an <strong>ordered</strong> arrangement of the elements of a set</li>
<li><strong><em>r-permutation</em></strong> : an <strong>ordered</strong> arrangement of <span class="arithmatex">\(r\)</span> elements of a set</li>
</ul>
<p>【Theorem 1】 The number of <strong>r-permutations</strong> of a set with <span class="arithmatex">\(n\)</span> distinct elements is <span class="arithmatex">\(P(n, r)=n(n-1)(n-2)…(n-r+1)= n!/(n-r)!\)</span></p>
<h3 id="2-combination-组合">2. Combination 组合<a class="headerlink" href="#2-combination-组合" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>r-combination</strong>: an <strong>unordered</strong> selection of <span class="arithmatex">\(r\)</span> elements of a set </li>
</ul>
<p>Note: An <span class="arithmatex">\(r\)</span>-combination is simply a subset of a set with <span class="arithmatex">\(r\)</span> elements.</p>
<p><span class="arithmatex">\(C(n, r)\)</span>: the number of <span class="arithmatex">\(r\)</span>-combination of a set with <span class="arithmatex">\(n\)</span> element </p>
<p>【Theorem 2】 The number of <span class="arithmatex">\(r\)</span>-combination of a set with <span class="arithmatex">\(n\)</span> elements, where <span class="arithmatex">\(n\)</span> is a positive integer and <span class="arithmatex">\(r\)</span> is an integer with <span class="arithmatex">\(0≤r≤n\)</span>, equals <span class="arithmatex">\(n(n-1)(n-2)…(n-r+1)/r! = n!/r!(n-r)!\)</span></p>
<p>【Corollary】Combination Corollary: Let <span class="arithmatex">\(n\)</span> and <span class="arithmatex">\(r\)</span> be nonnegative integers with <span class="arithmatex">\(r ≤ n\)</span>. Then <span class="arithmatex">\(C(n，r)= C(n，n-r)\)</span></p>
<ul>
<li>A combinatorial proof of an identity:</li>
<li><strong>double counting proofs</strong> : uses counting arguments to prove that both sides of the identity count the same objects but in different ways.</li>
<li><strong>bijective proofs</strong> : show that there is a bijection between the sets of objects counted by the two sides of the identity.</li>
</ul>
<h2 id="64-binomial-coefficients">6.4 Binomial Coefficients<a class="headerlink" href="#64-binomial-coefficients" title="Permanent link">&para;</a></h2>
<p>[ Definition ] : A <strong><em>binomial expression 二项表达式</em></strong> is the sum of two terms, such as <span class="arithmatex">\(x + y\)</span>. (More generally, these terms can be products of constants and variables)</p>
<ul>
<li>
<p>【Theorem 1】<strong><em>The Binomial Theorem 二项式定理</em></strong> : Let <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(y\)</span> be varaibles, and let <span class="arithmatex">\(n\)</span> be a nonnegative integer. Then <span class="arithmatex">\((x+y)^n = \sum_{j = 0}^{n} \binom{n}{j}x^{n-j}y^{j}\)</span>
$$
\begin{align<em>}
(x + y)^n&amp;=\sum_{j = 0}^{n} \binom{n}{j}x^{n - j}y^{j}\
&amp;=\binom{n}{0}x<sup -="-" 1="1" n="n">{n}+\binom{n}{1}x</sup>
\end{align}y+\cdots+\binom{n}{n - 1}xy^{n - 1}+\binom{n}{n}y^{n</em>}
$$</p>
</li>
<li>
<p>【Theorem 2】 <strong><em>PASCAL’S Identity 帕斯卡恒等式</em></strong> : Let <span class="arithmatex">\(n\)</span> and <span class="arithmatex">\(k\)</span> be positive integers with <span class="arithmatex">\(k ≤ n\)</span>. Then 
  $$
  \binom{n+1}{k}=\binom{n}{k-1} + \binom{n}{k}
  $$</p>
</li>
<li>
<p>【Theorem 3】 <strong><em>Vandermonde’s Identity 范德蒙德恒等式</em></strong> : Let <span class="arithmatex">\(m\)</span>, <span class="arithmatex">\(n\)</span> and <span class="arithmatex">\(r\)</span> be nonnegative integer with <span class="arithmatex">\(r\)</span> not exceeding either <span class="arithmatex">\(m\)</span> or <span class="arithmatex">\(n\)</span>. Then 
  $$
  \binom{n+m}{r}=\sum_{k=0}^r\binom{n}{k}  \binom{m}{r-k}
  $$</p>
</li>
<li>
<p>【Corollary】If <span class="arithmatex">\(n\)</span> is a nonnegative integer. Then 
    $$
    \binom{2n}{n}=\sum_{k=0}<sup>n\binom{n}{k}</sup>2
    $$</p>
</li>
<li>
<p>【Theorem 4】Let <span class="arithmatex">\(n\)</span> and <span class="arithmatex">\(r\)</span> be nonnegative integer with <span class="arithmatex">\(r≤n\)</span>. Then 
  $$
  \binom{n+1}{r+1}=\sum_{j=r}^n\binom{r}{j}
  $$</p>
</li>
</ul>
<h2 id="65-generalized-permutations-and-combinations">6.5 Generalized Permutations and Combinations<a class="headerlink" href="#65-generalized-permutations-and-combinations" title="Permanent link">&para;</a></h2>
<h3 id="1-permutations-with-repetition">1. Permutations With Repetition<a class="headerlink" href="#1-permutations-with-repetition" title="Permanent link">&para;</a></h3>
<ul>
<li>
<h5 id="theorem-1the-number-of-r-permutations-of-a-set-of-n-objects-with-repetition-allowed-is-nr">【Theorem 1】The number of r-permutations of a set of n objects with repetition allowed is <span class="arithmatex">\(n^r\)</span>.<a class="headerlink" href="#theorem-1the-number-of-r-permutations-of-a-set-of-n-objects-with-repetition-allowed-is-nr" title="Permanent link">&para;</a></h5>
</li>
</ul>
<p>对包含 <span class="arithmatex">\(n\)</span> 类对象的集合进行 <span class="arithmatex">\(r\)</span> 排列，如果允许重复，则总数为 <span class="arithmatex">\(n^r\)</span></p>
<h3 id="2-combination-with-repetition">2. Combination With Repetition<a class="headerlink" href="#2-combination-with-repetition" title="Permanent link">&para;</a></h3>
<ul>
<li>
<h5 id="theorem-2there-are-c-n-1r-r-r-combination-from-a-set-with-n-elements-when-repetition-of-elements-is-allowed">【Theorem 2】There are <mark><span class="arithmatex">\(C (n-1+r, r)\)</span></mark> r-combination from a set with <span class="arithmatex">\(n\)</span> elements when repetition of elements is allowed.<a class="headerlink" href="#theorem-2there-are-c-n-1r-r-r-combination-from-a-set-with-n-elements-when-repetition-of-elements-is-allowed" title="Permanent link">&para;</a></h5>
</li>
</ul>
<p>对包含 <span class="arithmatex">\(n\)</span> 类对象的集合进行 <span class="arithmatex">\(r\)</span> 组合，如果允许重复，则总数<span class="arithmatex">\(C(n−1+r,r)=C(n−1+r,n−1)\)</span>，记作 <mark><span class="arithmatex">\(H_{n}^{r}\)</span></mark></p>
<blockquote>
<p>即 <span class="arithmatex">\(r\)</span> 个不可区分的物体放入 <span class="arithmatex">\(n\)</span> 个可区分的箱子中, 共 <span class="arithmatex">\(H_n^r=C_{n-1+r}^r\)</span> 种情况</p>
</blockquote>
<p><img src="images/image-20250416130507966.png" alt="image-20250416130507966" style="zoom:80%;" /></p>
<h3 id="permutations-of-sets-with-indistinguishable-objects">Permutations of Sets With Indistinguishable Objects<a class="headerlink" href="#permutations-of-sets-with-indistinguishable-objects" title="Permanent link">&para;</a></h3>
<p>n-Permutation with limited repetition <span class="arithmatex">\(A = { n_{1•} a_1 ,n_{2 •} a_2 ,…,n_{k •} a_k } ，where n_1 +n_2 +…+n_k = n\)</span></p>
<ul>
<li>
<h5 id="theorem-3-the-number-of-different-permutations-of-n-objects-where-there-are-n_1-indistinguishable-objects-of-type1and-n_k-indistinguishable-objects-of-type-k-is-fracnn_1-n_2-ldots-n_k">【Theorem 3】 The number of different permutations of <span class="arithmatex">\(n\)</span> objects, where there are <span class="arithmatex">\(n_1\)</span> indistinguishable objects of type1,…,and <span class="arithmatex">\(n_k\)</span> indistinguishable objects of type k, is  <mark><span class="arithmatex">\(\frac{n!}{n_1! n_2! \ldots n_k!}\)</span></mark><a class="headerlink" href="#theorem-3-the-number-of-different-permutations-of-n-objects-where-there-are-n_1-indistinguishable-objects-of-type1and-n_k-indistinguishable-objects-of-type-k-is-fracnn_1-n_2-ldots-n_k" title="Permanent link">&para;</a></h5>
</li>
</ul>
<p>对 <span class="arithmatex">\(n\)</span> 个物体进行排列，其中有 <span class="arithmatex">\(n_i\)</span> 个属于类型 <span class="arithmatex">\(i\)</span> 的物体<span class="arithmatex">\((i=1,2,\dots,n)\)</span>，则排列种数为<span class="arithmatex">\(\frac{n!}{n_1! n_2! \ldots n_k!}\)</span></p>
<p><img src="images/image-20250416131025490.png" alt="image-20250416131025490" style="zoom:130%;" /></p>
<h3 id="3-distributing-objects-into-boxes">3. Distributing objects into boxes<a class="headerlink" href="#3-distributing-objects-into-boxes" title="Permanent link">&para;</a></h3>
<h4 id="31-distinguishable-objects-and-distinguishable-boxes">3.1 Distinguishable Objects and Distinguishable Boxes<a class="headerlink" href="#31-distinguishable-objects-and-distinguishable-boxes" title="Permanent link">&para;</a></h4>
<p>【Theorem 4】The number of ways to distribute <span class="arithmatex">\(n\)</span> distinguishable objects into <span class="arithmatex">\(k\)</span> distinguishable boxes so that <span class="arithmatex">\(n_i\)</span> objects are place into box <span class="arithmatex">\(i\)</span>, <span class="arithmatex">\(i=1,2,…,k\)</span>, equals <mark><span class="arithmatex">\(\frac{n!}{n_1 !n_2 !…n_k!}\)</span></mark>
<em>将 <span class="arithmatex">\(n\)</span> 个可区别的物体放入 <span class="arithmatex">\(k\)</span> 个可区分的箱子中，<span class="arithmatex">\(n_i\)</span> 表示第 <span class="arithmatex">\(i\)</span>个箱子中物体的数量</em></p>
<h4 id="32-indistinguishable-objects-and-distinguishable-boxes">3.2 Indistinguishable Objects and Distinguishable Boxes<a class="headerlink" href="#32-indistinguishable-objects-and-distinguishable-boxes" title="Permanent link">&para;</a></h4>
<p>There are <mark><span class="arithmatex">\(C(n  − 1+k, k)\)</span></mark> ways to place <span class="arithmatex">\(k\)</span> indistinguishable objects into <span class="arithmatex">\(n\)</span> distinguishable boxes.
<em>将  <span class="arithmatex">\(r\)</span> 个不可区分的物体放入 <span class="arithmatex">\(n\)</span> 个可区分的箱子</em></p>
<h4 id="33-distinguishable-objects-and-indistinguishable-boxes">3.3 Distinguishable Objects and Indistinguishable Boxes<a class="headerlink" href="#33-distinguishable-objects-and-indistinguishable-boxes" title="Permanent link">&para;</a></h4>
<p>counting the ways to place <span class="arithmatex">\(n\)</span> distinguishable objects into <span class="arithmatex">\(k\)</span> indistinguishable boxes
 <em>将 <span class="arithmatex">\(n\)</span> 个可区分物体放入 <span class="arithmatex">\(j\)</span> 个不可区分的箱子</em></p>
<p><strong><em>Stirling numbers of the second kind 第二类斯特林数</em></strong></p>
<ul>
<li>
<p>the number of ways to distribute <span class="arithmatex">\(n\)</span> <strong>distinguishable objects</strong> into <span class="arithmatex">\(j\)</span> <strong>indistinguishable boxes</strong> so that no boxes is empty. </p>
</li>
<li>
<p><strong>Notation:  <mark><span class="arithmatex">\(S(n,j)\)</span></mark></strong> ——<u>将 <span class="arithmatex">\(n\)</span> 个可区分物体放入 <span class="arithmatex">\(j\)</span> 个不可区分的箱子，且每个箱子<strong>非空</strong>的方法数</u></p>
</li>
<li>
<p><span class="arithmatex">\(S(r,1)=S(r,r) = 1\)</span></p>
</li>
<li><span class="arithmatex">\(S(r,2) = 2^{r-1}-1\)</span></li>
<li><span class="arithmatex">\(S(r,r-1)=S(r,2)\)</span></li>
<li>
<p><span class="arithmatex">\(S(r+1,n) = S(r,n-1)+nS(r,n)\)</span></p>
</li>
<li>
<p>利用容斥原理，可得
  $$
  S(n,j) =  \frac{1}{j!} \sum ^{j} _{i=0}(-1)^i \binom{j}{i}(j-i)^n
  $$</p>
</li>
</ul>
<p>因此，将 <span class="arithmatex">\(n\)</span> 个可区分物体放入 <span class="arithmatex">\(k\)</span> 个不可区分的箱子的方法数为
  $$
  \sum ^k <em j="1">{j=1} S(n,j) = \sum ^k </em>(j-i)^n
  $$} \frac{1}{j!} \sum ^{j} _{i=0}(-1)^i \binom{j}{i</p>
<h4 id="34-indistinguishable-objects-and-indistinguishable-boxes">3.4 Indistinguishable Objects and Indistinguishable Boxes<a class="headerlink" href="#34-indistinguishable-objects-and-indistinguishable-boxes" title="Permanent link">&para;</a></h4>
<blockquote>
<p>注：没有闭合公式能够求解这类问题</p>
</blockquote>
<h4 id="note">Note:<a class="headerlink" href="#note" title="Permanent link">&para;</a></h4>
<ol>
<li><span class="arithmatex">\(S(n, j)\)</span> is the number of ways to partition the set with <span class="arithmatex">\(n\)</span> elements into <span class="arithmatex">\(j\)</span> nonempty and disjoint subsets.</li>
<li><span class="arithmatex">\(S(n, j)j!\)</span> is the number of ways to distribute <span class="arithmatex">\(n\)</span> distinguishable objects into <span class="arithmatex">\(j\)</span> distinguishable boxes so that no boxes is empty </li>
<li>the number of onto functions from a set with <span class="arithmatex">\(n\)</span> elements to a set with <span class="arithmatex">\(j\)</span> elements
    <span class="arithmatex">\(S(n, j)j! = \left(\sum_{i = 0}^{j - 1} (-1)^i C_j^i (j - i)^n\right)\)</span></li>
<li>the number of ways to place <span class="arithmatex">\(n\)</span> distinguishable objects into <span class="arithmatex">\(k\)</span> indistinguishable boxes
    <span class="arithmatex">\(\sum_{j = 1}^{k} S(n, j)=\sum_{j = 1}^{k} \left(\left(\sum_{i = 0}^{j - 1} (-1)^i C_j^i (j - i)^n\right)/j!\right)\)</span></li>
</ol>
<h1 id="ch8-advanced-counting-techniques">Ch8 Advanced Counting Techniques<a class="headerlink" href="#ch8-advanced-counting-techniques" title="Permanent link">&para;</a></h1>
<h2 id="81-applications-of-recurrence-relations">8.1 Applications of Recurrence Relations<a class="headerlink" href="#81-applications-of-recurrence-relations" title="Permanent link">&para;</a></h2>
<h3 id="recurrence-relations">Recurrence Relations<a class="headerlink" href="#recurrence-relations" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> A recurrence relation for the sequence <span class="arithmatex">\(\{a_n \}\)</span> is an equation that express <span class="arithmatex">\(a_n\)</span> in terms of one or more of the previous terms of the sequence, namely, <span class="arithmatex">\(a_0,a_1,\dots,a_{n-1}\)</span>, for all integers $ n$ with <span class="arithmatex">\(n≥n_0\)</span>, where <span class="arithmatex">\(n_0\)</span> is a nonnegative integers. <span class="arithmatex">\(a_n  = f  (  a_0  ,  a_1  ,  a_2  ,  … , a_{n-1}  )   \space n≥n_0\)</span></p>
<ul>
<li>
<p><strong>A solution of a recurrence relation</strong> is a <strong>sequence</strong> if its terms satisfy the recurrence relation.</p>
</li>
<li>
<p>The <strong>degree</strong> of a recurrence relation  </p>
</li>
<li><span class="arithmatex">\(a_n = a_{n-1}  + a_{n-8}\)</span>   — a recurrence relation of degree <span class="arithmatex">\(8\)</span></li>
</ul>
<h3 id="algorithm-and-recurrence-relations">Algorithm and Recurrence relations<a class="headerlink" href="#algorithm-and-recurrence-relations" title="Permanent link">&para;</a></h3>
<ul>
<li>Dynamic programming algorithm</li>
<li>Divide-and-conquer algorithm</li>
</ul>
<h2 id="82-solving-linear-recurrence-relations">8.2 Solving Linear Recurrence Relations<a class="headerlink" href="#82-solving-linear-recurrence-relations" title="Permanent link">&para;</a></h2>
<h3 id="1-linear-homogeneous-recurrence-relations">1. Linear Homogeneous Recurrence Relations<a class="headerlink" href="#1-linear-homogeneous-recurrence-relations" title="Permanent link">&para;</a></h3>
<blockquote>
<p>线性齐次递推关系</p>
</blockquote>
<p><strong><em>k 阶常系数线性齐次递推关系 (linear homogeneous recurrence relation of degree k with constant coefficient)</em></strong>
<span class="arithmatex">\(a_n=c_1a_{n−1}+c_2a_{n−2}+\dots+c_ka_{n−k}\)</span> where <span class="arithmatex">\(c_1 , c_2 ,\dots, c_k\)</span>  are real numbers, and <span class="arithmatex">\(c_k  ≠0\)</span></p>
<ul>
<li><strong><em>linear 线性</em></strong>：等号右边是序列中前几项与常系数之积的和</li>
<li><strong><em>homogeneous 齐次</em></strong>：每项次数不超过 1</li>
<li><strong><em>constant 常数</em></strong>：序列中的每一项系数都是常数，而非关于 <span class="arithmatex">\(n\)</span> 的函数</li>
<li><strong><em>degree k阶</em></strong>：<span class="arithmatex">\(a_n\)</span> 是由序列中的前<span class="arithmatex">\(k\)</span>项表达的</li>
</ul>
<h3 id="2-solving-linear-homogeneous-recurrence-relation-with-constant-coefficients">2. Solving Linear Homogeneous Recurrence Relation With Constant Coefficients<a class="headerlink" href="#2-solving-linear-homogeneous-recurrence-relation-with-constant-coefficients" title="Permanent link">&para;</a></h3>
<blockquote>
<p>求解常系数线性齐次递推关系</p>
</blockquote>
<h4 id="21-two-key-ideas-to-find-all-their-solutions">2.1 <strong>Two key ideas to find all their solutions:</strong><a class="headerlink" href="#21-two-key-ideas-to-find-all-their-solutions" title="Permanent link">&para;</a></h4>
<ol>
<li><strong>These recurrence relations have solutions of the form <span class="arithmatex">\(a_n = r_n\)</span>, where <span class="arithmatex">\(r\)</span> is a constant</strong>
   这种递推关系有形如 <mark><span class="arithmatex">\(a_n=r^n\)</span></mark> 的解，<span class="arithmatex">\(r\)</span> 为常数。</li>
</ol>
<p>$$
\begin{align}
    r<sup n-1="n-1">n-c_1r</sup>-c_2r<sup n-k="n-k">{n-2}-\dots--c_kr</sup>=0\
    r<sup>{n-k}(r</sup>k-c_1r<sup k-2="k-2">{k-1}-c_2r</sup>-\dots--c_k)=0\
    r<sup k-1="k-1">k-c_1r</sup>-\dots--c_k=0
    \end{align}
$$
* The sequence }-c_2r^{k-2<span class="arithmatex">\(\{a_n\}\)</span> with <span class="arithmatex">\(a_n = r_n\)</span> where <span class="arithmatex">\(r ≠ 0\)</span> is a solution if and only if <span class="arithmatex">\(r\)</span> is a solution of this last equation.</p>
<blockquote>
<p>我们称上述方程为<strong>特征方程 (characteristic equation)</strong>，称这个方程的解为<strong>特征根 (characteristic roots)</strong></p>
</blockquote>
<ol>
<li>
<p><strong>A linear combination of two solutions of a linear homogeneous recurrence relation is also a solution.</strong> </p>
</li>
<li>
<p>suppose that <span class="arithmatex">\(s_n\)</span> and <span class="arithmatex">\(t_n\)</span> are both solutions of this recurrence relation. Then
  线性齐次递推关系的两个解的<strong>线性组合</strong>也是它的解
$$
  s_n=c_1s_{n-1}+c_2s_{n-2}+\dots+c_ks_{n-k}\
  t_n=c_1t_{n-1}+c_2t_{n-2}+\dots+c_kt_{n-k}\
$$
   Now suppose that <span class="arithmatex">\(b_1\)</span> and <span class="arithmatex">\(b_2\)</span> are real numbers. Then
$$
  b_1s_n+b_2t_n=c_1(b_1s_{n-1}+b_2t_{n-1})+c_2(b_1s_{n-2}+b_2t_{n-2})+\dots+c_k(b_1s_{n-k}+b_2t_{n-k})
$$
This means that <mark><span class="arithmatex">\(b_1 s_n + b_2 t_n\)</span></mark> is also a <strong>solution</strong> of the same linear homogeneous recurrence relation. </p>
</li>
</ol>
<h4 id="22-the-degree-two-case">2.2 The Degree Two Case<a class="headerlink" href="#22-the-degree-two-case" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p><strong>[ Theorem 1 ]</strong> 
  Let <span class="arithmatex">\(c_,c_2\)</span> be real numbers. Suppose that <span class="arithmatex">\(r^2-c_1r-c_2=0\)</span> has <strong><em><u>two distinct roots</u></em></strong> <span class="arithmatex">\(r_1,r_2\)</span>. Then the sequence <span class="arithmatex">\(\{a_n\}\)</span> is a solution of the recurrence relation <span class="arithmatex">\(a_n=c_1a_{n-1}+c_2a_{n-2}\)</span> if and only if ==$a_n=\alpha_1r_1<sup>n+\alpha_2r_2</sup>n <span class="arithmatex">\(==\)</span>\space for \space n=0,1,2,\dots$ where <span class="arithmatex">\(\alpha_1,\alpha_2\)</span> are constants. </p>
</li>
<li>
<p><strong>[ Theorem 2 ]</strong>
   Let $ c_1, c_2 $ be real numbers with $ c_2 \neq 0 $. Suppose that $ r^2 - c_1 r - c_2 = 0 $ has <strong><em><u>only one root</u></em></strong> $r_0 $. A sequence ${a_n} $ is a solution of the recurrence relation $a_n = c_1 a_{n-1} + c_2 a_{n-2} $ if and only if ==$a_n = (\alpha_1 + \alpha_2 n )r_0^n <span class="arithmatex">\(==\)</span>\text{ for } n = 0, 1, 2, \ldots, $ where $\alpha_1, \alpha_2 $ are constants.</p>
</li>
</ul>
<h4 id="2the-general-case">2.The General Case<a class="headerlink" href="#2the-general-case" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p><strong>[ Theorem 3 ]</strong>
  Let <span class="arithmatex">\(c_1, c_2, \ldots, c_k\)</span> be real numbers. Suppose that the characteristic equation <span class="arithmatex">\(r^k - c_1 r^{k-1} - \ldots - c_k = 0\)</span> has <span class="arithmatex">\(k\)</span> <strong><em><u>distinct roots</u></em></strong> <span class="arithmatex">\(r_1, r_2, \ldots, r_k\)</span>. Then a sequence <span class="arithmatex">\(\{a_n\}\)</span> is a solution of the recurrence relation
  <span class="arithmatex">\(a_n = c_1 a_{n-1} + c_2 a_{n-2} + \ldots + c_k a_{n-k}\)</span> if and only if <mark><span class="arithmatex">\(a_n = \alpha_1 r_1^n + \alpha_2 r_2^n + \ldots + \alpha_k r_k^n\)</span></mark> for <span class="arithmatex">\(n = 0, 1, 2, \ldots\)</span>, where <span class="arithmatex">\(\alpha_1, \alpha_2, \ldots, \alpha_k\)</span> are constants.</p>
</li>
<li>
<p><strong>[ Theorem 4 ]</strong>
  Let <span class="arithmatex">\(c_1, c_2, \ldots, c_k\)</span> be real numbers. Suppose that the characteristic equation <span class="arithmatex">\(r^k - c_1 r^{k-1} - \ldots - c_k = 0\)</span> has <strong><em><u>t distinct roots t个不同的根</u></em></strong> <span class="arithmatex">\(r_1, r_2, \ldots, r_t\)</span> with <strong><em><u>multiplicities重数</u></em></strong> <span class="arithmatex">\(m_1, m_2, \ldots, m_t\)</span>, respectively, so that <span class="arithmatex">\(m_i \geq 1\)</span> for <span class="arithmatex">\(i = 1, 2, \ldots, t\)</span> and <span class="arithmatex">\(m_1 + m_2 + \ldots + m_t = k\)</span>. Then a sequence <span class="arithmatex">\(\{a_n\}\)</span> is a solution of the recurrence relation <span class="arithmatex">\(a_n = c_1 a_{n-1} + c_2 a_{n-2} + \ldots + c_k a_{n-k}\)</span> if and only if
$$
\begin{aligned}
a_n = &amp; \left( \alpha_{1,0} + \alpha_{1,1} n + \cdots + \alpha_{1,m_1-1} n^{m_1-1} \right) r_1^n \
&amp; + \left( \alpha_{2,0} + \alpha_{2,1} n + \cdots + \alpha_{2,m_2-1} n^{m_2-1} \right) r_2^n \
&amp; + \cdots + \left( \alpha_{t,0} + \alpha_{t,1} n + \cdots + \alpha_{t,m_t-1} n^{m_t-1} \right) r_t^n
\end{aligned}
$$
​       for <span class="arithmatex">\(n = 0, 1, 2, \ldots\)</span> where <span class="arithmatex">\(\alpha_{i,j}\)</span> are constants for <span class="arithmatex">\(1 \leq i \leq t, 0 \leq j \leq m_i - 1\)</span>.</p>
</li>
</ul>
<h3 id="3-linear-nonhomogeneous-recurrence-relation-with-constant-coefficients">3. Linear Nonhomogeneous Recurrence Relation With Constant Coefficients<a class="headerlink" href="#3-linear-nonhomogeneous-recurrence-relation-with-constant-coefficients" title="Permanent link">&para;</a></h3>
<blockquote>
<p>常系数线性非齐次递推关系</p>
</blockquote>
<p><strong><em>k 阶常系数线性非齐次递推关系 (linear nonhomogeneous recurrence relation of degree k with constant coefficient)</em></strong>：
<span class="arithmatex">\(a_n=c_1a_{n−1}+c_2a_{n−2}+\dots+c_ka_{n−k}+F(n)\)</span> where <span class="arithmatex">\(c_1 , c_2 ,\dots, c_k\)</span>  are real numbers, <span class="arithmatex">\(F(n)\)</span> is a <strong>function</strong> not  identically zero depending only on <span class="arithmatex">\(n\)</span>
<span class="arithmatex">\(a_n=c_1a_{n−1}+c_2a_{n−2}+\dots+c_ka_{n−k}\)</span> is called <strong><em>关联齐次递推关系 (associated homogeneous recurrence relation)</em></strong></p>
<p><strong>[ Theorem 5 ]</strong></p>
<ul>
<li>Let <span class="arithmatex">\(\{a_n^{(p)}\}\)</span> be <strong><em>a particular solution 特殊解</em></strong> of <u>the nonhomogeneous linear</u> recurrence relation with constant coefficients</li>
</ul>
<p>$$
a_n = c_1 a_{n-1} + c_2 a_{n-2} + \ldots + c_k a_{n-k} + F(n)
$$
Then every solution is of the form <mark><span class="arithmatex">\(\{a_n^{(p)} + a_n^{(h)}\}\)</span></mark>, where <span class="arithmatex">\(\{a_n^{(h)}\}\)</span> is <strong>a solution</strong> of <u>the associated homogeneous recurrence relation</u>.</p>
<blockquote>
<p>虽然没有通法来找到关于任意函数 <span class="arithmatex">\(F(n)\)</span> 的解，但是对于某些类型的函数，比如多项式或者常数幂，是有办法可以解决的，如<u>定理6</u></p>
</blockquote>
<p><strong>[ Theorem 6 ]</strong></p>
<ul>
<li>Assume <strong><em>a linear nonhomogeneous recurrence equation with constant coefficients</em></strong> with the nonlinear part <span class="arithmatex">\(F(n)\)</span> of the form</li>
<li>
<p>The solution is <mark><span class="arithmatex">\(F(n) = (b_t n^t + b_{t-1} n^{t-1} + \ldots + b_1 n + b_0) s^n\)</span></mark></p>
</li>
<li>
<p>If <span class="arithmatex">\(s\)</span> is <strong>not</strong> a root of the characteristic equation of the associated homogeneous recurrence equation, there is a particular solution of the form
   ( <span class="arithmatex">\(s\)</span>不是关联齐次递推关系的特征方程的根 )</p>
</li>
<li>
<p>The solution is <mark><span class="arithmatex">\((p_t n^t + p_{t-1} n^{t-1} + \dots + p_1 n + p_0) s^n\)</span></mark></p>
</li>
<li>
<p>If <span class="arithmatex">\(s\)</span> is <strong><u>a root of multiplicity <span class="arithmatex">\(m\)</span></u></strong>, a particular solution is of the form
   ( <span class="arithmatex">\(s\)</span>是关联齐次递推关系的特征方程的根，重数为<span class="arithmatex">\(m\)</span> )</p>
</li>
<li>The solution is <mark><span class="arithmatex">\(n^m (p_t n^t + p_{t-1} n^{t-1} + \dots + p_1 n + p_0) s^n\)</span></mark></li>
</ul>
<h2 id="84-generating-functions">8.4 Generating Functions<a class="headerlink" href="#84-generating-functions" title="Permanent link">&para;</a></h2>
<p><strong>[ Definition ]</strong> The <strong><em>generating function生成函数</em></strong> for the sequence <span class="arithmatex">\(a_1,a_2,\dots,a_k,\dots\)</span> of real numbers is the <strong><em>infinite series无限级数</em></strong>.
$$
G(x)=a_0+a_1x+a_2x<sup>2+\dots+a_kx</sup>k+\dots=\sum_{k=0}<sup>{\infty}a_kx</sup>k
$$</p>
<ul>
<li>The generating function for <strong><em>finite</em></strong> sequence of real numbers <span class="arithmatex">\(a_0,a_1,a_2,\dots,a_n\)</span> is 
  $$
  G(x)=a_0+a_1x+a_2x<sup>2+\dots+a_nx</sup>n
  $$</li>
</ul>
<h3 id="useful-facts-about-power-series">Useful Facts About Power Series<a class="headerlink" href="#useful-facts-about-power-series" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>[ Theorem 1 ]</strong> Let <span class="arithmatex">\(f(x)=\sum_{k=0}^{\infty}a_k x^k, g(x)=\sum_{k=0}^{\infty}b_k x^k\)</span>. Then</li>
<li>
<div class="arithmatex">\[ f(x)+g(x)=\sum_{k = 0}^{\infty}(a_{k}+b_{k})x^{k}  \]</div>
</li>
<li>
<div class="arithmatex">\[ \alpha\cdot f(x)=\sum_{k = 0}^{\infty}\alpha\cdot a_{k}x^{k}\quad \alpha\in R \]</div>
</li>
<li>
<div class="arithmatex">\[ x\cdot f^{\prime}(x)=\sum_{k = 0}^{\infty}k\cdot a_{k}x^{k} \]</div>
</li>
<li>
<div class="arithmatex">\[ f(\alpha x)=\sum_{k = 0}^{\infty}\alpha^{k}\cdot a_{k}x^{k} \]</div>
</li>
<li>
<div class="arithmatex">\[ f(x)g(x)=\sum_{k = 0}^{\infty}(\sum_{j = 0}^{k}a_{j}b_{k - j})x^{k} \]</div>
</li>
</ul>
<h4 id="the-extended-binomial-coefficient"><strong>The extended binomial coefficient</strong><a class="headerlink" href="#the-extended-binomial-coefficient" title="Permanent link">&para;</a></h4>
<p>Recall <span class="arithmatex">\(\binom{m}{k}=C(m,k)= \frac{m!}{k!(m-k)!}\)</span></p>
<p><strong>[ Definition ]</strong> Let <span class="arithmatex">\(u\)</span> be a real number and <span class="arithmatex">\(k\)</span> a nonnegative integer. Then the <strong><em>extended binomial coefficient扩展二项式系数</em></strong> is defined by $$ \begin{pmatrix} u \ k \end{pmatrix}= \begin{cases} u(u - 1)\cdots(u - k + 1)/k! &amp;\text{if } k &gt; 0 \ 1 &amp;\text{if } k = 0 \end{cases} $$ </p>
<ul>
<li>If <span class="arithmatex">\(n &gt; 0\)</span>, then <span class="arithmatex">\(\binom{-n}{r}=(-1)^r\binom{n+r-1}{r}=(-1)^rC(n+r-1,r)\)</span></li>
</ul>
<h4 id="the-extended-binomial-theorem"><strong>The extended Binomial Theorem</strong><a class="headerlink" href="#the-extended-binomial-theorem" title="Permanent link">&para;</a></h4>
<p><strong>[ Theorem 2 ]</strong> Let <span class="arithmatex">\(x\)</span> be a real number with <span class="arithmatex">\(|x|&lt;1\)</span> and let <span class="arithmatex">\(u\)</span> be a real number. Then 
$$
(1+x)<sup _infty="\infty">u=\sum_{k=0}</sup>x^k
$$
}\binom{u}{k<img alt="image-20250423201104412" src="images/image-20250423201104412.png" /></p>
<h3 id="counting-problems-and-generating-functions">Counting Problems and Generating Functions<a class="headerlink" href="#counting-problems-and-generating-functions" title="Permanent link">&para;</a></h3>
<p><img src="images/image-20250423201325630.png" alt="image-20250423201325630" style="zoom:80%;" /></p>
<h3 id="use-generating-function-to-solve-recurrence-relations">Use Generating Function To Solve Recurrence Relations<a class="headerlink" href="#use-generating-function-to-solve-recurrence-relations" title="Permanent link">&para;</a></h3>
<p><img src="images/image-20250423201416355.png" alt="image-20250423201416355" style="zoom:80%;" /></p>
<h3 id="proving-identities-via-generating-functions">Proving Identities Via Generating Functions<a class="headerlink" href="#proving-identities-via-generating-functions" title="Permanent link">&para;</a></h3>
<blockquote>
<p>略</p>
</blockquote>
<h2 id="85-inclusion-exclusion-and-its-application">8.5 Inclusion-Exclusion and Its Application<a class="headerlink" href="#85-inclusion-exclusion-and-its-application" title="Permanent link">&para;</a></h2>
<h3 id="the-principle-of-inclusion-exclusion">The Principle of inclusion-exclusion<a class="headerlink" href="#the-principle-of-inclusion-exclusion" title="Permanent link">&para;</a></h3>
<blockquote>
<p>容斥原理</p>
</blockquote>
<p>The formula for the number of elements in the union of <span class="arithmatex">\(n\)</span> finite sets:
$$
\left|A_1\cup A_2\cup\cdots\cup A_n\right| = \sum_{i = 1}^{n}\left|A_i\right| - \sum_{1\leq i &lt; j\leq n}\left|A_i\cap A_j\right| + \sum_{1\leq i &lt; j &lt; k\leq n}\left|A_i\cap A_j\cap A_k\right|+\cdots+(- 1)^{n - 1}\left|A_1\cap A_2\cap\cdots\cap A_n\right|
$$</p>
<ul>
<li>There are <span class="arithmatex">\(2^n − 1\)</span> terms in this formula</li>
</ul>
<h2 id="86-applications-of-inclusion-exclusion">8.6 Applications of Inclusion-Exclusion<a class="headerlink" href="#86-applications-of-inclusion-exclusion" title="Permanent link">&para;</a></h2>
<h3 id="an-alternative-form-of-inclusion-exclusion">An alternative form of inclusion-exclusion<a class="headerlink" href="#an-alternative-form-of-inclusion-exclusion" title="Permanent link">&para;</a></h3>
<ul>
<li>To solve problems that ask for the number of elements in a set that have none of n properties.</li>
</ul>
<p>$<span class="arithmatex">\(P_1,P_2,\dots,P_n\)</span>$</p>
<p>Let <span class="arithmatex">\(A_i\)</span> be the subset containing the elements that have property <span class="arithmatex">\(P_i\)</span>.</p>
<p><span class="arithmatex">\(N(P_1,P_2,\dots,P_k)\)</span> : The number of elements with all properties <span class="arithmatex">\(P_1,P_2,\dots,P_k\)</span></p>
<p>It follows that <span class="arithmatex">\(N(P_1,P_2,\dots,P_k)= \left|A_1\cap A_2\cap\cdots\cap A_k\right|\)</span></p>
<p><span class="arithmatex">\(N(P_1^{'},P_2^{'},\dots,P_k^{'})\)</span> : The number of elements with none properties <span class="arithmatex">\(P_1,P_2,\dots,P_k\)</span></p>
<p>From the inclusion-exclusion principle, we see that
  $$
  N(P_1<sup _="'">{'},P_2</sup>N(P_i P_j)+\dots+(-1)^n N(P_1P_2\dots P_n)
  $$},\dots,P_n^{'})=N-\sum_{1 \leq i \leq n}N(P_i)+\sum_{1 \leq i &lt; j \leq n</p>
<h3 id="the-number-of-onto-functions">The number of onto functions<a class="headerlink" href="#the-number-of-onto-functions" title="Permanent link">&para;</a></h3>
<p><strong>Theorem</strong>: Let <span class="arithmatex">\(m\)</span> and <span class="arithmatex">\(n\)</span> be positive integers with <span class="arithmatex">\(m\geq n\)</span>. Then, there are  <span class="arithmatex">\(n^m - C(n, 1)(n - 1)^m + C(n, 2)(n - 2)^m-\cdots+(-1)^{n - 1}C(n, n - 1)\cdot1^m\)</span> <strong>onto functions</strong> from a set with <span class="arithmatex">\(m\)</span> elements to a set with <span class="arithmatex">\(n\)</span> elements. </p>
<h3 id="derangements">Derangements<a class="headerlink" href="#derangements" title="Permanent link">&para;</a></h3>
<blockquote>
<p>全错位排列</p>
</blockquote>
<ul>
<li>A derangement is a permutation of objects that leaves no object in the original position.</li>
</ul>
<p><strong>Theorem</strong>: The number of derangements of a set with <span class="arithmatex">\(n\)</span> elements is
$$
D_n=n![1-\frac{1}{1!}+\frac{1}{2!}+\dots+(-1)^n\frac{1}{n!}]
\(NOTE:D_n=D_{n-1}+D_{n-2})
$$</p>
<h1 id="ch9-relations">Ch9 Relations<a class="headerlink" href="#ch9-relations" title="Permanent link">&para;</a></h1>
<h2 id="91-relations-and-their-properties">9.1 Relations and Their Properties<a class="headerlink" href="#91-relations-and-their-properties" title="Permanent link">&para;</a></h2>
<h3 id="1-functions-as-relations">1. Functions as Relations<a class="headerlink" href="#1-functions-as-relations" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Binary relation</strong></li>
</ul>
<p><strong>[Definition] ** A </strong>binary relation二元关系** <span class="arithmatex">\(R\)</span> from a set <span class="arithmatex">\(A\)</span> to a set <span class="arithmatex">\(B\)</span> is a subset of <span class="arithmatex">\(A×B\)</span>.</p>
<p><strong>Note</strong> :</p>
<ul>
<li>A binary relation <span class="arithmatex">\(R\)</span> is a set</li>
<li><span class="arithmatex">\(R \subseteq A\times B\)</span></li>
<li><span class="arithmatex">\(R = \{(a,b)|a \in A,b \in B, aRb \}\)</span></li>
</ul>
<p>Relations are a <strong><em>generalization泛化</em></strong> of function.</p>
<h3 id="2-relations-on-a-set">2. Relations On A Set<a class="headerlink" href="#2-relations-on-a-set" title="Permanent link">&para;</a></h3>
<p><strong>[Definition]</strong> A relation on the set <span class="arithmatex">\(A\)</span> is a <strong>relation</strong> form <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(A\)</span></p>
<ul>
<li>
<p><span class="arithmatex">\(R \subseteq A\times A\)</span></p>
</li>
<li>
<p>A set <span class="arithmatex">\(A\)</span> with <span class="arithmatex">\(n\)</span> elements has <span class="arithmatex">\(2^{n^2}\)</span> binary relations</p>
</li>
</ul>
<h3 id="3-properties-of-binary-relations">3. Properties of Binary Relations<a class="headerlink" href="#3-properties-of-binary-relations" title="Permanent link">&para;</a></h3>
<h4 id="31-reflexive-relations">3.1 Reflexive Relations<a class="headerlink" href="#31-reflexive-relations" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong><em>reflexive自反性</em></strong> if $(x,x)\in R,\text{for every element }x\in A $, <span class="arithmatex">\(\forall x (x\in A\rightarrow (x, x)\in R)\)</span></p>
<ul>
<li>All the elements on the <strong><em>main diagonal主对角线</em></strong> of a matrices must be <strong>1s</strong></li>
<li>There is a <strong><em>loop环</em></strong> at every vertex of the directed graph</li>
</ul>
<p><strong>【Definition】</strong> A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong><em>irreflexive非自反性</em></strong> if <span class="arithmatex">\(\forall x (x\in A\rightarrow (x, x)\notin R)\)</span></p>
<ul>
<li>All the elements on the <strong><em>main diagonal主对角线</em></strong> of a matrices must be <strong>0s</strong></li>
</ul>
<h4 id="32-symmetric-relations">3.2 Symmetric Relations<a class="headerlink" href="#32-symmetric-relations" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong><em>symmetric对称性</em></strong> if <span class="arithmatex">\(\forall x \forall y ((x,y)\in R\rightarrow (y, x)\in R)\)</span></p>
<blockquote>
<p><span class="arithmatex">\((a,b)=(b,a)\)</span> 恒成立</p>
</blockquote>
<p><strong>【Definition】</strong>A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong><em>antisymmetric 反对称性</em></strong> if <span class="arithmatex">\(\forall x \forall y ((x,y)\in R \and (y,x)\in R\rightarrow x=y)\)</span></p>
<p><strong>【Definition】</strong>A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong><em>asymmetric 不对称性</em></strong> if <span class="arithmatex">\(\forall x \forall y ((x,y)\in R \rightarrow (y,x)\notin R)\)</span></p>
<blockquote>
<ul>
<li>对称性和反对称性不是对立的，一个关系可能同时具有对称性和反对称性</li>
</ul>
</blockquote>
<h4 id="33-transitive-relations">3.3 Transitive Relations<a class="headerlink" href="#33-transitive-relations" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong><em>transitive传递性</em></strong> if  <span class="arithmatex">\(\forall x \forall y \forall z (  (x,y)\in R \and (y,z)\in R \rightarrow (x,z) \in R  )\)</span></p>
<ul>
<li><span class="arithmatex">\(\overline{(m_{ij} \and m_{jk})} \or m_{ik} = 1\)</span></li>
<li>If there is an arc from <span class="arithmatex">\(x\)</span> to <span class="arithmatex">\(y\)</span> and one from <span class="arithmatex">\(y\)</span> to <span class="arithmatex">\(z\)</span> then there  must be one from <span class="arithmatex">\(x\)</span> to <span class="arithmatex">\(z\)</span>.  </li>
</ul>
<h3 id="4-combining-relations">4. Combining Relations<a class="headerlink" href="#4-combining-relations" title="Permanent link">&para;</a></h3>
<p>Since relations form <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span> are subsets of <span class="arithmatex">\(A×B\)</span>, two relations form <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span> can be combined in any way two sets can be combined (Set operation <span class="arithmatex">\(\cup, \cap, -,⊕\)</span>).  </p>
<h4 id="composition复合">Composition复合<a class="headerlink" href="#composition复合" title="Permanent link">&para;</a></h4>
<p>Let <span class="arithmatex">\(R=\{(a,b)|a \in A, b \in B, aRb\}\)</span> , $ S={ (b,c)|b\in B, c \in C,bSc }$,</p>
<p>Then <span class="arithmatex">\(S∘R=\{ (a,c)|a \in A \and c \in C \and \exist b (b \in B \and aRb \and bSc) \}\)</span></p>
<ul>
<li>Note : <span class="arithmatex">\(S∘R \neq R∘S\)</span></li>
</ul>
<h4 id="inverse-relation">Inverse relation<a class="headerlink" href="#inverse-relation" title="Permanent link">&para;</a></h4>
<p><span class="arithmatex">\(R=\{(a,b)|a\in A,b \in B, aRb\}\)</span></p>
<p>The inverse relation form B to A : <span class="arithmatex">\(R^{-1}(R^c)=\{ (b,a)|(a,b)\in R,a \in A, b \in B \}\)</span></p>
<h4 id="the-properties-of-relation-operations">The properties of relation operations<a class="headerlink" href="#the-properties-of-relation-operations" title="Permanent link">&para;</a></h4>
<p>Suppose that <span class="arithmatex">\(R, S\)</span> are the relations from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span>, <span class="arithmatex">\(T\)</span> is the relation from <span class="arithmatex">\(B\)</span> to <span class="arithmatex">\(C\)</span>, <span class="arithmatex">\(P\)</span> is the relation from <span class="arithmatex">\(C\)</span> to <span class="arithmatex">\(D\)</span>, then</p>
<ol>
<li><span class="arithmatex">\((R\cup S)^{-1} = R^{-1}\cup S^{-1}\)</span></li>
<li><span class="arithmatex">\((R\cap S)^{-1} = R^{-1}\cap S^{-1}\)</span></li>
<li><span class="arithmatex">\((\overline{R})^{-1}=\overline{R^{-1}}\)</span></li>
<li><span class="arithmatex">\((R- S)^{-1} = R^{-1}- S^{-1}\)</span></li>
<li><span class="arithmatex">\((A\times B)^{-1} = B \times A\)</span></li>
<li><span class="arithmatex">\(\overline{R}=A\times B-R\)</span></li>
<li><span class="arithmatex">\((S∘T)^{-1}=T^{-1}∘S^{-1}\)</span></li>
<li><span class="arithmatex">\((R∘T)∘P=R∘(T∘P)\)</span></li>
<li><span class="arithmatex">\((R\cup S)∘T=R∘T\cup S∘T\)</span></li>
</ol>
<h4 id="the-power-of-a-relation-r">The Power of a relation R<a class="headerlink" href="#the-power-of-a-relation-r" title="Permanent link">&para;</a></h4>
<p>【Definition】Let <span class="arithmatex">\(R\)</span> be a relation on the set <span class="arithmatex">\(A\)</span>. The powers <span class="arithmatex">\(R^n , n=1,2,3, \dots\)</span>  are defined inductively by <span class="arithmatex">\(R^1=R\)</span> and <span class="arithmatex">\(R^{n+1}=R^n∘R\)</span></p>
<p>【Theorem】The relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is <strong>transitive</strong> if and only if <span class="arithmatex">\(R^n \subseteq R, for\space n=1,2,\dots\)</span></p>
<ul>
<li>If <span class="arithmatex">\(R\)</span> is reflexive, then <span class="arithmatex">\(R^n\)</span> is reflexive</li>
<li>If <span class="arithmatex">\(R\)</span> is symmetric, then <span class="arithmatex">\(R^n\)</span> is symmetric</li>
</ul>
<h2 id="92-n-ary-relations">9.2 <strong>n-ary Relations</strong><a class="headerlink" href="#92-n-ary-relations" title="Permanent link">&para;</a></h2>
<p><strong>[ Definition ] ** Let <span class="arithmatex">\(A_1,A_2,\dots,A_n\)</span> be sets, An </strong><em>n-ary relation</em>** on these sets is a subset of <span class="arithmatex">\(A_1×A_2×\dots ×A_n\)</span>.</p>
<h2 id="93-representing-relations">9.3 Representing Relations<a class="headerlink" href="#93-representing-relations" title="Permanent link">&para;</a></h2>
<p><strong>The methods of representing relation</strong>:  </p>
<ul>
<li>list its all ordered pairs </li>
<li>using a set build notation/specification by predicates  </li>
<li>2D table </li>
<li>Connection matrix /zero-one matrix </li>
<li>Directed graph/Digraph</li>
</ul>
<h3 id="1-connection-matrices">1. Connection Matrices<a class="headerlink" href="#1-connection-matrices" title="Permanent link">&para;</a></h3>
<p><strong>[ Definition ]</strong> : Let <span class="arithmatex">\(R\)</span> be a relation from <span class="arithmatex">\(A = \{a_1,a_2,\dots,a_m\}\)</span>, to <span class="arithmatex">\(B=\{b_1, b_2, \dots b_n\}\)</span>, 
An <span class="arithmatex">\(m \times n\)</span> <strong><em>connection matrix连接矩阵</em></strong> <span class="arithmatex">\(M_R=[m_{ij}]\)</span> for <span class="arithmatex">\(R\)</span> is defined by
$$
m_{ij}= \begin{cases} 1 &amp; \text{if } (a_i, b_j)\in R, \ 0 &amp; \text{if } (a_i, b_j)\notin R. \end{cases}
$$</p>
<h3 id="2-directed-graphdigraph">2. Directed graph/Digraph<a class="headerlink" href="#2-directed-graphdigraph" title="Permanent link">&para;</a></h3>
<p><strong>[ Definition ]</strong> A <strong><em>directed graph</em></strong> or a <strong><em>digraph</em></strong>, consists of a set <span class="arithmatex">\(V\)</span> of vertices together with a set <span class="arithmatex">\(E\)</span> of ordered pairs of elements of <span class="arithmatex">\(V\)</span> called <strong><em>edges(or arcs)</em></strong>. The <strong><em>vertices</em></strong> <span class="arithmatex">\(a,b\)</span> is called the <strong>initial</strong> and <strong>terminal</strong> vertices of the edge <span class="arithmatex">\((a,b)\)</span>.</p>
<h2 id="94-closures-of-relations">9.4 Closures of Relations<a class="headerlink" href="#94-closures-of-relations" title="Permanent link">&para;</a></h2>
<p><strong>【Definition】</strong>The <strong><em>closure闭包</em></strong> of a relation <span class="arithmatex">\(R\)</span> with respect to property <span class="arithmatex">\(P\)</span> is the relation <span class="arithmatex">\(S\)</span> with property <span class="arithmatex">\(P\)</span>
containing <span class="arithmatex">\(R\)</span> such that <span class="arithmatex">\(S\)</span> is a subset of every relation with property <span class="arithmatex">\(P\)</span> containing <span class="arithmatex">\(R\)</span>.</p>
<p>如果 <span class="arithmatex">\(R\)</span> 是在集合 <span class="arithmatex">\(A\)</span>上的关系，那么 <span class="arithmatex">\(R\)</span> 关于性质 <span class="arithmatex">\(P\)</span> 的<strong>闭包 (closure)</strong>，它满足性质 <span class="arithmatex">\(P\)</span> 且包括 <span class="arithmatex">\(R\)</span>，而且是所有包含 <span class="arithmatex">\(R\)</span> 且满足 <span class="arithmatex">\(P\)</span> 的 <span class="arithmatex">\(A×A\)</span> 的子集</p>
<blockquote>
<p>The smallest relation with property <span class="arithmatex">\(P\)</span> containing $R $</p>
</blockquote>
<h3 id="1-reflexive-closure">1. Reflexive Closure<a class="headerlink" href="#1-reflexive-closure" title="Permanent link">&para;</a></h3>
<p><strong>【Theorem】</strong>Let <span class="arithmatex">\(R\)</span> be a relation on <span class="arithmatex">\(A\)</span>. The <strong><em>reflexive closure自反闭包</em></strong> of <span class="arithmatex">\(R\)</span>, denoted by <span class="arithmatex">\(r(R)\)</span>, is <span class="arithmatex">\(R\cup I_A\)</span>(The <strong><em>diagonal relation对角关系</em></strong> on A, <span class="arithmatex">\(I_A=\{ (x,x)|x\in A\}\)</span>).</p>
<p><strong>【Corollary】</strong><span class="arithmatex">\(R=R\cup I_A\)</span> ⇔ <span class="arithmatex">\(R\)</span> is a reflexive relation</p>
<h3 id="2-symmetric-closure">2. Symmetric Closure<a class="headerlink" href="#2-symmetric-closure" title="Permanent link">&para;</a></h3>
<p><strong>【Theorem】</strong>Let <span class="arithmatex">\(R\)</span> be a relation on <span class="arithmatex">\(A\)</span>. The <strong><em>symmetric closure对称闭包</em></strong> of <span class="arithmatex">\(R\)</span>, denoted by <span class="arithmatex">\(r(R)\)</span>, is <span class="arithmatex">\(R\cup R^{-1}\)</span></p>
<p><strong>【Corollary】</strong><span class="arithmatex">\(R=R\cup R^{-1}\)</span> ⇔ <span class="arithmatex">\(R\)</span> is a symmetric relation</p>
<h3 id="3-transitive-closure">3. Transitive closure<a class="headerlink" href="#3-transitive-closure" title="Permanent link">&para;</a></h3>
<ul>
<li><span class="arithmatex">\(t(R)\)</span> : the smallest transitive relation containing <span class="arithmatex">\(R\)</span></li>
</ul>
<p><strong>Terminologies术语</strong>:</p>
<ul>
<li><u><strong><em>A path of length n in a digraph G</em></strong></u> </li>
<li>A sequence of edges <span class="arithmatex">\((x_0,x_1),\dots,(x_{n-1},x_n)\)</span></li>
<li>Notation: <span class="arithmatex">\(x_0,x_1,\dots,x_n\)</span></li>
<li><strong><em><u>Cycle or circuit</u></em></strong> </li>
<li>If there is a sequence of edges <span class="arithmatex">\((x_0,x_1),\dots,(x_{n-1},x_n)\)</span>, and <span class="arithmatex">\(x_0 = x_n\)</span>​</li>
</ul>
<p>The term path also applies to relation.  </p>
<p><strong>【Theorem1】</strong> <mark>Let <span class="arithmatex">\(R\)</span> be a relation on <span class="arithmatex">\(A\)</span>. There is a path of length <span class="arithmatex">\(n\)</span> from <span class="arithmatex">\(a\)</span> to <span class="arithmatex">\(b\)</span> if and only if <span class="arithmatex">\((a,b)\in R^n\)</span></mark></p>
<h4 id="connectivity-relation">Connectivity Relation<a class="headerlink" href="#connectivity-relation" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong> The <strong><em>connectivity relation联通关系</em></strong> denote by <span class="arithmatex">\(R^*\)</span>, is the set of ordered pairs <span class="arithmatex">\((a,b)\)</span> such that there is a path (in <span class="arithmatex">\(R\)</span>) from <span class="arithmatex">\(a\)</span> to <span class="arithmatex">\(b\)</span>, </p>
<ul>
<li>then is easy to get the equation: <span class="arithmatex">\(R^*=\cup^{\infty}_{n=1}R^n\)</span></li>
</ul>
<p><strong>【Theorem2】</strong> <span class="arithmatex">\(R\)</span> 的传递闭包 <span class="arithmatex">\(t(R)\)</span> <span class="arithmatex">\(=\)</span> 连通关系<span class="arithmatex">\(R^*\)</span></p>
<ul>
<li><span class="arithmatex">\(R=t(R) ⇔\text{R is transitive}\)</span> </li>
<li>In fact, we need only consider paths of length <span class="arithmatex">\(n\)</span> or less.  </li>
</ul>
<p><strong>【Theorem】</strong> If <span class="arithmatex">\(|A | = n\)</span>, then any <u>path of length &gt; n</u> must contain a cycle. </p>
<p><strong>【Theorem】</strong>If <span class="arithmatex">\(|A|=n\)</span>, <span class="arithmatex">\(R\)</span> is a relation on <span class="arithmatex">\(A\)</span>, then <span class="arithmatex">\(\exist k,k\leq n,R^*=R\cup R^2\cup \dots\cup R^k\)</span></p>
<ul>
<li><strong>【Corollary】</strong> If <span class="arithmatex">\(|A|=n\)</span>, then <span class="arithmatex">\(t(R)=R^*=R\cup R^2 \cup \dots \cup R^n\)</span></li>
<li><strong>【Corollary】</strong> Let <span class="arithmatex">\(M_R\)</span> be the zero-one matrix of the relation <span class="arithmatex">\(R\)</span> on a set with <span class="arithmatex">\(n\)</span> elements. The zero-one matrix of the transitive closure is <span class="arithmatex">\(M_{t(R)}=M_R \or M_R^{[2]}]  \or \dots\or M_R ^{[n]}\)</span></li>
</ul>
<h3 id="4-warshalls-algorithm">4. Warshall's Algorithm<a class="headerlink" href="#4-warshalls-algorithm" title="Permanent link">&para;</a></h3>
<p>The interior vertices of a path: <span class="arithmatex">\(x_0, x_1, x_2, \ldots, x_{n - 1}, x_n\)</span></p>
<p><strong>Warshall's algorithm</strong> is based on the construction of a sequence of <strong>zero-one matrices</strong>, such as <span class="arithmatex">\(W_0, W_1, W_2, \ldots, W_n\)</span></p>
<ul>
<li>$ W_0 = M_R $ and $W_k = [w_{ij}^{(k)}] $</li>
</ul>
<div class="arithmatex">\[
w_{ij}^{(k)}= \begin{cases} 1 &amp; \text{If there is a path from } V_i \text{ to } V_j \text{ such that all the interior vertices of this path }\\ &amp;\text{are in the set } \{V_1, V_2, \ldots, V_k\}\\ 0 &amp; \text{otherwise} \end{cases}
\]</div>
<ul>
<li>$ W_n = M_{t(R)} $</li>
<li>$ w_{ij}<sup -="-" 1_="1)" _k="(k">{(k)}=w_{ij}</sup>)$}\vee(w_{ik}^{(k - 1)}\wedge w_{kj}^{(k - 1)</li>
</ul>
<h2 id="95-equivalence-relations">9.5 Equivalence Relations<a class="headerlink" href="#95-equivalence-relations" title="Permanent link">&para;</a></h2>
<h3 id="1-equivalence-relations">1. Equivalence Relations<a class="headerlink" href="#1-equivalence-relations" title="Permanent link">&para;</a></h3>
<p><strong>【Definition】</strong>A relation <span class="arithmatex">\(R\)</span> on a set <span class="arithmatex">\(A\)</span> is an <strong><em>equivalence relation等价关系</em></strong> if <span class="arithmatex">\(R\)</span> is <u><strong>reflexive, symmetric , transitive</strong></u>.</p>
<ul>
<li>a and b are <strong><em>equivalent相关</em></strong> (<span class="arithmatex">\(a\)</span>~<span class="arithmatex">\(b\)</span>) : <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are related by an equivalence relation <span class="arithmatex">\(R\)</span></li>
</ul>
<h3 id="2-equivalence-classes">2. Equivalence Classes<a class="headerlink" href="#2-equivalence-classes" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><em>the equivalence class等价类</em></strong> of <span class="arithmatex">\(x\)</span>:
  The set of all elements that are related to an element <span class="arithmatex">\(x\)</span> of <span class="arithmatex">\(A\)</span></li>
<li>Notation : <span class="arithmatex">\([a]_R\)</span>,   <span class="arithmatex">\([a]_R=\{s ∣ (a,s)∈R\}\)</span></li>
<li>a representative of the equivalence class <span class="arithmatex">\([a]_{R}\)</span> : <span class="arithmatex">\(b\in [a]_R\)</span></li>
</ul>
<h3 id="3-partition-of-a-set">3. Partition of a Set<a class="headerlink" href="#3-partition-of-a-set" title="Permanent link">&para;</a></h3>
<p><strong>【Definition】</strong>Let be a collection of subsets of <span class="arithmatex">\(A\)</span>. Then the collection forms a <strong><em>partition分区</em></strong> of <span class="arithmatex">\(A\)</span> if and only if</p>
<ul>
<li><span class="arithmatex">\(A_i \neq \empty \text{ for }i \in Z\)</span></li>
<li><span class="arithmatex">\(A_i \cap A_j = \empty, when \space i \neq j\)</span></li>
<li><span class="arithmatex">\(\forall a \in A,\exist i\text{ such that }a \in A_i(i=1,2,\dots)\)</span>  [ <span class="arithmatex">\(\cup_{i\in Z}A_i=A\)</span> ]</li>
</ul>
<p><img alt="image-20250509225218227" src="images/image-20250509225218227.png" /></p>
<blockquote>
<p>贝尔数 <span class="arithmatex">\(B_n=\sum_{k=1}^{n}S(n,k)\)</span> , 满足<span class="arithmatex">\(B_{n+1}=\sum_{k=0}^{n}\binom{n}{k}B_k\)</span>,</p>
<p>贝尔数代表集合有多少种划分方式，也代表集合具有的equivalence relation的数量</p>
</blockquote>
<h3 id="4-equivalence-classes-and-partitions">4. Equivalence Classes and Partitions<a class="headerlink" href="#4-equivalence-classes-and-partitions" title="Permanent link">&para;</a></h3>
<p><strong>【Theorem 1】</strong>Let <span class="arithmatex">\(R\)</span> be an <strong><em>equivalence relation</em></strong> on a set <span class="arithmatex">\(A\)</span>. The following statements are equivalent :</p>
<ul>
<li><span class="arithmatex">\(aRb\)</span></li>
<li><span class="arithmatex">\([a]=[b]\)</span></li>
<li><span class="arithmatex">\([a]\cap [b]=\empty\)</span></li>
</ul>
<p><strong>【Theorem 2】</strong> Let <span class="arithmatex">\(R\)</span> be an equivalence relation on a set <span class="arithmatex">\(A\)</span>. Then the equivalence classes of <span class="arithmatex">\(R\)</span> form a partition of <span class="arithmatex">\(A\)</span>. Conversely, given a partition, <span class="arithmatex">\(\{A_i|i\in I\}\)</span> of the set <span class="arithmatex">\(A\)</span>, there is an equivalence relation <span class="arithmatex">\(R\)</span> that has the sets <span class="arithmatex">\(A_i,i\in I\)</span>, as its equivalence classes.</p>
<h3 id="5-the-operations-of-equivalence-relations">5. The operations of equivalence relations<a class="headerlink" href="#5-the-operations-of-equivalence-relations" title="Permanent link">&para;</a></h3>
<p><strong>【Theorem 3】</strong> If <span class="arithmatex">\(R_1,R_2\)</span> are equivalence relations on <span class="arithmatex">\(A\)</span>, then <span class="arithmatex">\(R_1\cap R_2\)</span> is equivalence relations on <span class="arithmatex">\(A\)</span>.</p>
<p><strong>【Theorem 4】</strong> If <span class="arithmatex">\(R_1,R_2\)</span> are equivalence relations on <span class="arithmatex">\(A\)</span>, then <span class="arithmatex">\(R_1\cup R_2\)</span> is reflexive and symmetric relation on <span class="arithmatex">\(A\)</span>.</p>
<p><strong>【Theorem 5】</strong> If <span class="arithmatex">\(R_1,R_2\)</span> are equivalence relations on <span class="arithmatex">\(A\)</span>, then <span class="arithmatex">\((R_1\cup R_2)^*\)</span> is an equivalence relation on <span class="arithmatex">\(A\)</span>.</p>
<h2 id="96-partial-orderings">9.6 Partial Orderings<a class="headerlink" href="#96-partial-orderings" title="Permanent link">&para;</a></h2>
<h3 id="1-basic-concepts">1. Basic Concepts<a class="headerlink" href="#1-basic-concepts" title="Permanent link">&para;</a></h3>
<ul>
<li>【Definition】Let <span class="arithmatex">\(R\)</span> be a relation on <span class="arithmatex">\(S\)</span>. Then <span class="arithmatex">\(R\)</span> is a <strong><em><mark>partial ordering</mark> or partial order偏序</em></strong> if <span class="arithmatex">\(R\)</span> is </li>
<li><strong>reflexive</strong> </li>
<li><strong>antisymmetric</strong> - <span class="arithmatex">\(\forall x \forall y ((x,y)\in R \and (y,x)\in R\rightarrow x=y)\)</span></li>
<li><strong>transitive</strong> </li>
<li>Notation : <span class="arithmatex">\((S,R)\)</span>--- partially ordered set or a <strong><em>poset偏序集</em></strong></li>
</ul>
<h4 id="comparable-incomparable"><strong>Comparable/ Incomparable</strong><a class="headerlink" href="#comparable-incomparable" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>The elements <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> of a poset <span class="arithmatex">\((S,⪯)\)</span> are called <strong><em>comparable可比</em></strong> if either <span class="arithmatex">\(a⪯b\)</span> or <span class="arithmatex">\(b⪯a\)</span>. When <span class="arithmatex">\(a\)</span> and $b $ are elements of <span class="arithmatex">\(S\)</span> such that neither <span class="arithmatex">\(a⪯b\)</span> or <span class="arithmatex">\(b⪯a\)</span> are called <strong><em>incomparable不可比</em></strong>.   </p>
<h4 id="total-orderlinear-order"><strong>Total order/Linear order</strong><a class="headerlink" href="#total-orderlinear-order" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong> If <span class="arithmatex">\((S,⪯)\)</span> is a poset and every two elements of <span class="arithmatex">\(S\)</span> are comparable, <span class="arithmatex">\(S\)</span> is called a <strong><em>totally  ordered or linearly ordered set全序集</em></strong>,  <span class="arithmatex">\(⪯\)</span> is called a <strong><em><mark>total order</mark> or linear order全序</em></strong>. In this case is called a <strong><em>chain链</em></strong>. </p>
<h4 id="well-ordered">Well-ordered<a class="headerlink" href="#well-ordered" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong> <span class="arithmatex">\((S, ≼)\)</span> is a <strong><em>well-ordered set良序集</em></strong> if it is a poset such that <span class="arithmatex">\(≼\)</span> is a <strong>total ordering</strong> and every nonempty subset of <span class="arithmatex">\(S\)</span> has <strong>a least element</strong>. </p>
<p><strong>【Theorem】The principle of well-ordered induction良序归纳法原则</strong> 
Suppose that <span class="arithmatex">\(S\)</span> is a well-ordered set. 
Then <span class="arithmatex">\(P(x)\)</span> is true for all <span class="arithmatex">\(x∈S\)</span> ,if :
For every <span class="arithmatex">\(y∈S\)</span>, if <span class="arithmatex">\(P(x)\)</span> is true for all <span class="arithmatex">\(x∈S\)</span> with <span class="arithmatex">\(x&lt;y\)</span>,  then <span class="arithmatex">\(P(y)\)</span> is true.</p>
<h3 id="2-lexicographic-order">2. Lexicographic Order<a class="headerlink" href="#2-lexicographic-order" title="Permanent link">&para;</a></h3>
<p>The lexicographic order <span class="arithmatex">\(≼\)</span> on <span class="arithmatex">\(A_1\times A_2\)</span></p>
<ul>
<li>
<p>Given two posets <span class="arithmatex">\((A_1,≼_1)\)</span> and <span class="arithmatex">\((A_2,≼_2)\)</span>, we construct an induced partial order <span class="arithmatex">\(R\)</span> on <span class="arithmatex">\(A_1\times A_2\)</span>: <span class="arithmatex">\((x_1,y_1)≼ (x_2,y_2)\)</span> if <span class="arithmatex">\(x_1 ≼ x_2\)</span> or <span class="arithmatex">\(x_1=x_2 \and y_1≼ y_2\)</span>       </p>
</li>
<li>
<p>A lexicographic ordering is a partial ordering defined on a Cartesian product of two posets.</p>
</li>
</ul>
<p>词典序是两个偏序集的笛卡尔积的偏序</p>
<ul>
<li>The definition of lexicographic order extends naturally to multiple Cartesian products of partially ordered sets</li>
</ul>
<h3 id="3-hasse-diagrams">3. Hasse Diagrams<a class="headerlink" href="#3-hasse-diagrams" title="Permanent link">&para;</a></h3>
<p>To construct a <strong><em>Hasse diagram哈斯图</em></strong> :</p>
<p>1)  画出偏序的有向图
2)  因为偏序是<em>自反的</em>，所以每个顶点都会有一个<strong><em>环</em></strong><span class="arithmatex">\((a,a)\)</span>，将这些环全部移除
3)  由于其他边的存在和传递性，我们需要移除所有多余的边，即当存在元素 <span class="arithmatex">\(z∈S\)</span> 使得 <span class="arithmatex">\(x≺z\)</span> 且 <span class="arithmatex">\(z≺y\)</span>时，移除边 <span class="arithmatex">\((x,y)\)</span>
4)  对所有边重新排序，使得<strong><em>起点在终点的下面</em></strong>，并且移除所有箭头 ( 因为现在所有的边都是向上指的，方向已知 )</p>
<p><img src="images/image-20250603193832040.png" alt="image-20250603193832040" style="zoom:120%;" /></p>
<h4 id="chain-and-antichain">Chain and Antichain<a class="headerlink" href="#chain-and-antichain" title="Permanent link">&para;</a></h4>
<p>【Definition】<span class="arithmatex">\((A,≼ )\)</span> is a poset. <span class="arithmatex">\(B\subset A\)</span>, if <span class="arithmatex">\((B,≼)\)</span> is a totally ordered set, the <span class="arithmatex">\(B\)</span> is called a <strong><em>chain</em></strong> of <span class="arithmatex">\((A,≼)\)</span>        </p>
<p>【Definition】<span class="arithmatex">\((A,≼ )\)</span> is a poset. <span class="arithmatex">\(B\subset A\)</span>, if <span class="arithmatex">\(\forall a,b \in B(a\neq b),(a,b)\notin R,(b,a)\notin R\)</span>, the <span class="arithmatex">\(B\)</span> is called a <strong><em>antichain</em></strong> of <span class="arithmatex">\((A,≼)\)</span>  </p>
<ul>
<li>The length of chain: <span class="arithmatex">\(|B|\)</span>, <span class="arithmatex">\(B\)</span> is a definite set</li>
</ul>
<h3 id="4-maximal-and-minimal-elements">4. Maximal and Minimal Elements<a class="headerlink" href="#4-maximal-and-minimal-elements" title="Permanent link">&para;</a></h3>
<p><strong>【Definition】</strong> Let <span class="arithmatex">\((A,≼ )\)</span> be a poset. <span class="arithmatex">\(a\in A\)</span>, then <span class="arithmatex">\(a\)</span> is a <strong><em>maximal element极大元素</em></strong> if there does not exist an element <span class="arithmatex">\(b\)</span> in <span class="arithmatex">\(A\)</span> such that <span class="arithmatex">\(a≺b\)</span>. Similarly for a <strong><em>minimal element极小元素</em></strong>. </p>
<p><strong>Note</strong>: </p>
<ol>
<li>Maximal and minimal elements are the <u><strong>“top” and “bottom”</strong></u> elements in the Hasse diagram. </li>
<li>There can be <u><strong>more than one</strong></u> minimal and maximal element in a poset.</li>
</ol>
<h4 id="greatest-and-least-element">Greatest and Least Element<a class="headerlink" href="#greatest-and-least-element" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>Let <span class="arithmatex">\((A,≼ )\)</span> be a poset. Then an element $ a$ in <span class="arithmatex">\(A\)</span> is a <strong><em>greatest element最大元素</em></strong> of <span class="arithmatex">\(A\)</span> if <span class="arithmatex">\(b⪯a\)</span> for every <span class="arithmatex">\(b\)</span> in <span class="arithmatex">\(A\)</span>, and <span class="arithmatex">\(a\)</span> is a <strong><em>least element最小元素</em></strong> of <span class="arithmatex">\(A\)</span> if <span class="arithmatex">\(a⪯b\)</span> for every <span class="arithmatex">\(b\)</span> in $ A$.</p>
<p><strong>【Theorem】</strong> The greatest and least element are <strong>unique</strong> when they exist.</p>
<h4 id="upper-and-lower-bounds">Upper and Lower Bounds<a class="headerlink" href="#upper-and-lower-bounds" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>Let <span class="arithmatex">\(A\)</span> be a subset of <span class="arithmatex">\(S\)</span> in the poset <span class="arithmatex">\((S,≼ )\)</span>.  If there exists an element <span class="arithmatex">\(u\)</span> in <span class="arithmatex">\(S\)</span> such that <span class="arithmatex">\(a≼ u\)</span> for all <span class="arithmatex">\(a\)</span> in <span class="arithmatex">\(A\)</span>, then <span class="arithmatex">\(u\)</span> is called an <strong><em>upper bound上界</em></strong> of <span class="arithmatex">\(A\)</span>. Similarly for lower bounds.</p>
<p><strong>【Definition】</strong>If <span class="arithmatex">\(a\)</span> is an upper bound for <span class="arithmatex">\(P\)</span> which is less than every other upper bounds then it is the least upper bound, denoted by <span class="arithmatex">\(lub(S)\)</span>. Similarly for the greatest lower bound, denoted by <span class="arithmatex">\(glb(S)\)</span>.</p>
<h3 id="5-lattices">5. Lattices<a class="headerlink" href="#5-lattices" title="Permanent link">&para;</a></h3>
<p><strong>【Definition】</strong>A poset is called a <strong><em>lattice格</em></strong> if every pair of elements has a <span class="arithmatex">\(lub\)</span> and a <span class="arithmatex">\(glb\)</span>. </p>
<h3 id="6-topological-sorting">6. Topological Sorting<a class="headerlink" href="#6-topological-sorting" title="Permanent link">&para;</a></h3>
<p>We can impose a <strong>total ordering</strong> <span class="arithmatex">\(≼\)</span> on a poset <strong><em>compatible兼容</em></strong> with the <strong>partial order</strong> <span class="arithmatex">\(R\)</span> if <span class="arithmatex">\(a≼b\)</span> whenever <span class="arithmatex">\(aRb\)</span>.</p>
<blockquote>
<p>对于某个全序 <span class="arithmatex">\(⪯\)</span> 和偏序 <span class="arithmatex">\(R\)</span>，如果当 <span class="arithmatex">\(a R b\)</span> 时，<span class="arithmatex">\(a⪯b\)</span>，则称 <span class="arithmatex">\(⪯\)</span> 与 <span class="arithmatex">\(R\)</span> 是<strong>兼容的</strong></p>
</blockquote>
<ul>
<li>Constructing a compatible total ordering from a partial ordering is called <strong><em>topological sorting拓扑序</em></strong>.</li>
</ul>
<p><strong>【Lemma 1】</strong>Every finite nonempty poset <span class="arithmatex">\((S,  ≼)\)</span> has a minimal element</p>
<p><strong>Algorithm</strong>:  To sort a poset <span class="arithmatex">\((S, R)\)</span>. </p>
<ul>
<li>Select the <strong>minimal element</strong> <span class="arithmatex">\(s_1\)</span> form <span class="arithmatex">\(S\)</span> and put it in the list.</li>
<li>Select the <strong>minimal element</strong> <span class="arithmatex">\(s_2\)</span> form <span class="arithmatex">\(S-\{a_1\}\)</span> and put it in the list.</li>
<li>Select the <strong>minimal element</strong> <span class="arithmatex">\(s_3\)</span> form <span class="arithmatex">\(S-\{a_1,a_2\}\)</span> and put it in the list.</li>
<li>......</li>
<li>Continue until all elements appear in the list  (and <span class="arithmatex">\(S\)</span> is void).</li>
</ul>
<h1 id="ch10-graphs">Ch10 Graphs<a class="headerlink" href="#ch10-graphs" title="Permanent link">&para;</a></h1>
<h2 id="101-graphs-and-graph-models">10.1 Graphs and Graph Models<a class="headerlink" href="#101-graphs-and-graph-models" title="Permanent link">&para;</a></h2>
<h3 id="1-the-concept-of-graph">1. The Concept of Graph<a class="headerlink" href="#1-the-concept-of-graph" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>【Definition 1】</strong>A <strong><em>graph图</em></strong> <span class="arithmatex">\(G=(V,E)\)</span> consists of <span class="arithmatex">\(V\)</span>, a nonempty set of <strong><em>vertices顶点</em></strong> and <span class="arithmatex">\(E\)</span>, a set of <strong><em>edges 边</em></strong>. Each edge has either one or two vertices associated with it, called its <strong><em>endpoints端点</em></strong>. An edge is said to connect its endpoints.</li>
<li><strong>Infinite graph无限图</strong>: a graph with an infinite vertex set or an infinite number of edges</li>
<li><strong>Finite graph有限图</strong>: a graph with an finite vertex set and a finite number of edges</li>
<li><strong>【Definition 2】</strong>A <strong><em>directed graph有向图</em></strong> (or <strong><em>digraph</em></strong>) <span class="arithmatex">\((V, E)\)</span> consists of a nonempty set of vertices <span class="arithmatex">\(V\)</span> and a set of <strong>directed edges</strong> (or <strong>arcs</strong>) <span class="arithmatex">\(E\)</span>.<br />
  Each directed edge is associated with an ordered pair of vertices. The directed edge associated with the ordered pair <span class="arithmatex">\((u,v)\)</span> is said to start at <span class="arithmatex">\(u\)</span> and end at <span class="arithmatex">\(v\)</span>.</li>
</ul>
<h4 id="types-of-graphs"><strong>Types of Graphs</strong><a class="headerlink" href="#types-of-graphs" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Undirected graph无向图</strong> : a graph with <strong>undirected</strong> edges. </li>
<li><strong><em>Simple graph简单图</em></strong> : A graph in which each edge connects two different vertices and where <strong>no two edges connect the same pair of vertices</strong>. </li>
<li><strong><em>Multigraph多重图</em></strong> : Graphs that may have <strong>multiple edges</strong> connecting the same vertices.</li>
<li>
<p><strong><em>Pseudograph伪图</em></strong> : Graphs that may include <strong>loops</strong>, and possibly multiple edges connecting the same pair of vertices</p>
</li>
<li>
<p><strong>Directed graph有向图</strong> : a graph with <strong>directed</strong> edges. </p>
</li>
<li>
<p><strong><em>Simple directed graph简单有向图</em></strong> : a directed graph has <strong>no loops</strong> and has <strong>no multiple directed edges</strong>.</p>
</li>
<li>
<p><strong><em>Directed multigraph有向多重图</em></strong> : a directed graphs that may have <strong>multiple directed edges</strong>  from a vertex to a second (possibly the same)  vertex.</p>
</li>
<li>
<p><strong><em>Mixed graph混合图</em></strong> : a graph with <strong>both</strong> directed and undirected edges.    </p>
</li>
</ul>
<h3 id="2-graph-models">2. Graph Models<a class="headerlink" href="#2-graph-models" title="Permanent link">&para;</a></h3>
<blockquote>
<p>Omitted</p>
</blockquote>
<h2 id="102-graph-terminology-and-special-types-of-graphs">10.2 Graph Terminology and Special Types of Graphs<a class="headerlink" href="#102-graph-terminology-and-special-types-of-graphs" title="Permanent link">&para;</a></h2>
<h3 id="1-basic-terminology">1. Basic Terminology<a class="headerlink" href="#1-basic-terminology" title="Permanent link">&para;</a></h3>
<h4 id="undirected-graphs">Undirected Graphs<a class="headerlink" href="#undirected-graphs" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>Two vertices, u and v in an undirected graph G are called <strong><em>adjacent相邻</em></strong> (or <strong>neighbors</strong>) in <span class="arithmatex">\(G\)</span>, if <span class="arithmatex">\(\{u, v\}\)</span> is an edge of <span class="arithmatex">\(G\)</span>. </p>
</li>
<li>
<p>An edge <span class="arithmatex">\(e\)</span> connecting <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span> is called <strong><em>incident</em></strong> with vertices <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span>, or is said to <strong>connect <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span></strong>. </p>
</li>
<li>
<p>The vertices <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span> are called <strong>endpoints</strong> of edge <span class="arithmatex">\(\{u, v\}\)</span>. </p>
</li>
<li>
<p><strong>Loop</strong>: an edge connects a vertex to itself. </p>
</li>
<li>
<p>The <strong>neighborhood</strong> of <span class="arithmatex">\(v (N(v))\)</span>: the set of <strong>all neighbors</strong> of a vertex <span class="arithmatex">\(v\)</span> </p>
</li>
<li>
<p>The <strong><em>degree度数</em></strong> of a vertex in an undirected graph is the number of edges incident with it, except that a loop at a vertex contributes twice to the degree of that vertex     </p>
</li>
</ul>
<p>Notation: <span class="arithmatex">\(deg(v)\)</span>         </p>
<ul>
<li>If <span class="arithmatex">\(deg(v) = 0\)</span>, <span class="arithmatex">\(v\)</span> is called <strong>isolated孤立的</strong>.    </li>
<li>If <span class="arithmatex">\(deg(v) = 1\)</span>, <span class="arithmatex">\(v\)</span> is called <strong>pendant下垂的</strong>.</li>
</ul>
<p><strong>【Theorem 1】</strong> <mark><strong>The Handshaking Theorem握手定理</strong></mark> : Let <span class="arithmatex">\(G = (V, E)\)</span> be an undirected graph <span class="arithmatex">\(G\)</span> with <span class="arithmatex">\(e\)</span> edges. Then <span class="arithmatex">\(\sum_{v\in V}deg(v)=2e\)</span></p>
<p><strong>【Theorem 2】</strong> An undirected graph has an <strong>even number</strong> of vertices of odd degree. 在无向图中，度为<em>奇数</em>的顶点个数为偶数</p>
<h4 id="directed-graphs">Directed Graphs<a class="headerlink" href="#directed-graphs" title="Permanent link">&para;</a></h4>
<p>Let <span class="arithmatex">\((u, v)\)</span> be an edge in <span class="arithmatex">\(G\)</span>. Then <span class="arithmatex">\(u\)</span> is an <strong>initial vertex起点</strong> and is adjacent to <span class="arithmatex">\(v\)</span> and <span class="arithmatex">\(v\)</span> is a <strong>terminal vertex终点</strong> and is adjacent from <span class="arithmatex">\(u\)</span>. The <strong>in degree入度</strong> of a vertex <span class="arithmatex">\(v\)</span>, denoted <span class="arithmatex">\(deg⁻(v)\)</span>, is the number of edges which terminate at <span class="arithmatex">\(v\)</span>. Similarly, the <strong>out degree出度</strong> of v, denoted <span class="arithmatex">\(deg⁺(v)\)</span>, is the number of edges which initiate at <span class="arithmatex">\(v\)</span>. </p>
<p><strong>【Theorem 3】</strong>Let <span class="arithmatex">\(G = (V, E)\)</span> be a graph with direct edges. Then <span class="arithmatex">\(\sum_{v\in V}d^+(v)=\sum_{v\in V}d^-(v)=|E|\)</span></p>
<h3 id="2-some-special-simple-graphs">2. Some Special Simple Graphs<a class="headerlink" href="#2-some-special-simple-graphs" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><em>Complete Graphs完全图</em></strong> - <mark><span class="arithmatex">\(K_n\)</span></mark></li>
</ul>
<p>exactly <strong>one edge</strong> between <strong>every pair</strong> of distinct vertices</p>
<p><img src="images/image-20250603202522549.png" alt="image-20250603202522549" style="zoom:150%;" /></p>
<ul>
<li><strong><em>Cycles环</em></strong> - <mark><span class="arithmatex">\(C_n (n&gt;2)\)</span></mark></li>
</ul>
<p><span class="arithmatex">\(C_n=(V,E),where \space V=\{v_1,v_2,\dots , v_n\},E=\{(v_1,v_2),(v_2,v_3),\dots , (v_{n-1},v_n),(v_n,v_1)\},n \geq 3\)</span></p>
<p><img src="images/image-20250514201741328.png" alt="image-20250514201741328" style="zoom:70%;" /></p>
<ul>
<li><strong><em>Wheels轮</em></strong> - <mark><span class="arithmatex">\(W_n(n&gt;2)\)</span></mark></li>
</ul>
<p>Add one additional vertex to the cycle <span class="arithmatex">\(C_n\)</span> and add an edge from each vertex to the new vertex to produce <span class="arithmatex">\(W_n\)</span>.</p>
<p><img src="images/image-20250514201803199.png" alt="image-20250514201803199" style="zoom:80%;" /></p>
<ul>
<li><strong><em>n-Cubes</em></strong> - <mark><span class="arithmatex">\(Q_n (n&gt;0)\)</span></mark></li>
</ul>
<p>$<span class="arithmatex">\(Q_n = \langle V, E \rangle\)</span>$ is a graph with $<span class="arithmatex">\(2^n\)</span>$ vertices representing bit strings of length n, where <span class="arithmatex">\(V = \{ v | v = a_1a_2...a_n, a_i = 0, 1, i = 1, 2, ..., n \}\)</span> and <span class="arithmatex">\(E = \{ (u, v) | u, v \in V \land u \text{ and } v \text{ differ in exactly one bit position }\}.\)</span></p>
<p><img alt="image-20250514103428074" src="images/image-20250514103428074.png" /></p>
<blockquote>
<ul>
<li>
<p>Construct <span class="arithmatex">\(Q_{n+1}\)</span> from <span class="arithmatex">\(Q_n\)</span></p>
</li>
<li>
<p>making two copies of <span class="arithmatex">\(Q_n\)</span> , prefacing the labels on the vertices with a <span class="arithmatex">\(0\)</span> in one copy and with a <span class="arithmatex">\(1\)</span> in the other copy  </p>
</li>
<li>
<p>adding edges connecting two vertices that have labels differing only in the first bit </p>
<p><img alt="image-20250514103647388" src="images/image-20250514103647388.png" /> </p>
</li>
<li>
<p>The number of edges: <span class="arithmatex">\(a_n=2a_{n-1}+2^{n-1}\)</span></p>
</li>
</ul>
</blockquote>
<h3 id="3-bipartite-graphs">3. Bipartite Graphs<a class="headerlink" href="#3-bipartite-graphs" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>A simple graph $ G $ is <strong><em><mark>bipartite二分的</mark></em></strong> if $ V $ can be partitioned into two disjoint subsets $ V_1 $ and $ V_2 $ such that every edge connects a vertex in $ V_1 $ and a vertex in $ V_2 $. </p>
</li>
<li>
<p>The pair $ {V_1, V_2} $ is called a <strong><em>bipartition二分</em></strong> of the vertex $ V $ of $ G $.</p>
</li>
</ul>
<p><img alt="image-20250514104414459" src="images/image-20250514104414459.png" /></p>
<ul>
<li>
<p><strong>【Theorem 4】</strong> A simple graph is <strong>bipartite</strong> if and only if it is possible to assign one of <strong>two different colors</strong> to each vertex of the graph so that no two adjacent vertices are assigned the same color. </p>
</li>
<li>
<p>The <strong>complete bipartite graph完全二分图</strong> is the simple graph that has its vertex set partitioned into two subsets $ V_1 $ and $ V_2 $ with $ m $ and $ n $ vertices, respectively, and every vertex in $ V_1 $ is connected to every vertex in $ V_2 <span class="arithmatex">\(, denoted by ==\)</span> K_{m,n} $==, where $ m = |V_1| $ and $ n = |V_2| $.</p>
</li>
</ul>
<p><img alt="image-20250514104353981" src="images/image-20250514104353981.png" /></p>
<h3 id="4-regular-graph-regular-graph">4. Regular graph Regular graph<a class="headerlink" href="#4-regular-graph-regular-graph" title="Permanent link">&para;</a></h3>
<ul>
<li>A simply graph is called <mark><strong>regular</strong></mark> if every vertex of this graph has the <strong>same degree</strong>. </li>
<li>A regular graph is called <strong>n-regular</strong> if every vertex in this graph has degree <span class="arithmatex">\(n\)</span></li>
</ul>
<h3 id="5-new-graphs-from-old">5. New Graphs From Old<a class="headerlink" href="#5-new-graphs-from-old" title="Permanent link">&para;</a></h3>
<h4 id="subgraph"><strong>Subgraph</strong><a class="headerlink" href="#subgraph" title="Permanent link">&para;</a></h4>
<p>$ G = (V, E) $, $ H = (W, F) $    </p>
<ul>
<li>
<p>$ H $ is a <strong>subgraph子图</strong> of $ G $ if $ W\subseteq V$, <span class="arithmatex">\(F \subseteq E\)</span>.     </p>
</li>
<li>
<p>subgraph $ H $ is a <strong>proper subgraph真子图</strong> of $ G $ if $ H \neq G $.    </p>
</li>
<li>
<p>$ H $ is a <strong>spanning subgraph生成子图</strong> of <span class="arithmatex">\(G\)</span> if <span class="arithmatex">\(W = V\)</span>, <span class="arithmatex">\(F \subseteq E\)</span></p>
</li>
<li>
<p><strong>Subgraph induced点诱导子图</strong> by a subset of <span class="arithmatex">\(V\)</span></p>
</li>
</ul>
<p>Let <span class="arithmatex">\(G=(V,E)\)</span> be a simple graph. The subgraph induced by <u>a subset <strong><em>W</em></strong> of the vertex set <strong><em>V</em></strong></u> is the graph <span class="arithmatex">\((W,F)\)</span>, where the edge set <span class="arithmatex">\(F\)</span> contains an edge in <span class="arithmatex">\(E\)</span> iff both endpoints of this edge are in <span class="arithmatex">\(W\)</span></p>
<blockquote>
<p>定一个图 <span class="arithmatex">\(G=(V,E)\)</span>，其中 <span class="arithmatex">\(V\)</span> 是顶点集合，<span class="arithmatex">\(E\)</span> 是边集合，对于 <span class="arithmatex">\(V\)</span> 的任意非空子集 <span class="arithmatex">\(S\)</span>，由 <span class="arithmatex">\(S\)</span> 中的顶点以及 <span class="arithmatex">\(G\)</span> 中连接这些顶点的<strong>所有边</strong>组成的子图称为<strong><u>由 S 点诱导的子图</u></strong>。</p>
</blockquote>
<p><strong>得到新图的方式</strong></p>
<ul>
<li><strong>Removing edges of a graph</strong> : <span class="arithmatex">\(G-e=(V,E-\{e\})\)</span></li>
<li><strong>Adding edges to a graph</strong> : <span class="arithmatex">\(G+e=(V,E+\{e\})\)</span></li>
<li><strong>Edge contration 边压缩</strong> : <ol>
<li>Remove an edge <span class="arithmatex">\(e\)</span> with endpoints <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span>, </li>
<li>merge <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span> into a new single vertex <span class="arithmatex">\(w\)</span>, </li>
<li>and for each edge with <span class="arithmatex">\(u\)</span> or <span class="arithmatex">\(v\)</span> as an endpoint replaces the edge with one with <span class="arithmatex">\(w\)</span> as endpoint in place of <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span> and with the same second endpoint. </li>
</ol>
</li>
<li><strong>Removing vertices from a graph</strong> : <span class="arithmatex">\(G-v =(V-v, E’)\)</span>, where <span class="arithmatex">\(E’\)</span> is the set of edges of <span class="arithmatex">\(G\)</span> not incident to <span class="arithmatex">\(v\)</span></li>
</ul>
<h3 id="6-graph-union">6. Graph Union<a class="headerlink" href="#6-graph-union" title="Permanent link">&para;</a></h3>
<p>The union of two simple graphs <span class="arithmatex">\(G1 = ( V1 , E1 )\)</span> and <span class="arithmatex">\(G2 = ( V2 , E2 )\)</span> is the simple graph with vertex set <span class="arithmatex">\(V = V1 ∪ V2\)</span> and edge set <span class="arithmatex">\(E = E1 ∪ E2\)</span>. </p>
<ul>
<li>Notation:  <span class="arithmatex">\(G1 ∪ G2\)</span></li>
</ul>
<h2 id="103-representing-graphs-and-graph-isomorphism">10.3 Representing Graphs and Graph Isomorphism<a class="headerlink" href="#103-representing-graphs-and-graph-isomorphism" title="Permanent link">&para;</a></h2>
<h3 id="1-adjacency-lists">1. Adjacency lists<a class="headerlink" href="#1-adjacency-lists" title="Permanent link">&para;</a></h3>
<ul>
<li>lists that specify the vertices that are adjacent to each vertex</li>
</ul>
<p><img src="images/image-20250514204913332.png" alt="image-20250514204913332" style="zoom:80%;" /></p>
<h3 id="2-adjacency-matrices">2. Adjacency Matrices<a class="headerlink" href="#2-adjacency-matrices" title="Permanent link">&para;</a></h3>
<ul>
<li>A simple graph <span class="arithmatex">\(G = (V, E)\)</span> with <span class="arithmatex">\(n\)</span> vertices <span class="arithmatex">\((v_1,v_2,\dots,v_n)\)</span> can  be represented by its <strong><em>adjacency matrix邻接矩阵</em></strong>, <span class="arithmatex">\(A\)</span>, where <span class="arithmatex">\(a_{ij} = 1\)</span> if <span class="arithmatex">\(\{v_i, v_j \}\)</span> is an edge of <span class="arithmatex">\(G\)</span>, <span class="arithmatex">\(a_{ij} = 0\)</span> otherwise.</li>
</ul>
<p><img alt="image-20250514205654541" src="images/image-20250514205654541.png" /></p>
<ul>
<li>The adjacency matrix of a <strong>multigraph</strong> or <strong>pseudograph</strong></li>
</ul>
<p>The <span class="arithmatex">\((i, j)th\)</span> entry of such a matrix equals the number of edges that  are associated to <span class="arithmatex">\(\{v_i, v_j\}\)</span>.</p>
<p><img alt="image-20250514210048087" src="images/image-20250514210048087.png" /></p>
<ul>
<li>The adjacency matrix of a <strong>directed graph</strong></li>
</ul>
<p>For directed graph <span class="arithmatex">\(G = (V, E)\)</span> with <span class="arithmatex">\(|V| = n\)</span>, suppose that the vertices of <span class="arithmatex">\(G\)</span> are listed in arbitrary order as <span class="arithmatex">\(v_1, v_2, …, v_n\)</span>, the adjacency matrix <span class="arithmatex">\(A = [a_{ij}]\)</span>, where <span class="arithmatex">\(a_{ij} = 1\)</span> if <span class="arithmatex">\((v_i, v_j)\)</span> is an edge of <span class="arithmatex">\(G\)</span>, <span class="arithmatex">\(a_{ij} = 0\)</span> otherwise.</p>
<p><img alt="image-20250514210249748" src="images/image-20250514210249748.png" /></p>
<h3 id="3-incidence-matrices">3. Incidence matrices<a class="headerlink" href="#3-incidence-matrices" title="Permanent link">&para;</a></h3>
<p><span class="arithmatex">\(G = (V, E)\)</span>, <span class="arithmatex">\(V = \{v_1, v_2, ..., v_n\}\)</span>, <span class="arithmatex">\(E = \{e_1, e_2, ..., e_m\}\)</span>. The <strong><em>incidence matrix关联矩阵</em></strong> with respect to this ordering of <span class="arithmatex">\(V\)</span> and <span class="arithmatex">\(E\)</span> is an <span class="arithmatex">\(n \times m\)</span> matrix <span class="arithmatex">\(M = [m_{ij}]_{n \times m}\)</span>, where <span class="arithmatex">\(m_{ij} = \begin{cases} 1 &amp; \text{when edge } e_j \text{ is incident with } v_i \\ 0 &amp; \text{otherwise} \end{cases}\)</span></p>
<p><img src="images/image-20250514210326735.png" alt="image-20250514210326735" style="zoom:80%;" /></p>
<h3 id="4-isomorphism-of-graphs">4. Isomorphism Of Graphs<a class="headerlink" href="#4-isomorphism-of-graphs" title="Permanent link">&para;</a></h3>
<ul>
<li>Two simple graphs $ G_1 = (V_1, E_1) $ and $ G_2 = (V_2, E_2) $ are <strong>isomorphic同构的</strong> if there is a <span class="arithmatex">\(1-1\)</span> and onto function $ f $ ($ f $ is called an <strong>isomorphism</strong>) from $ V_1 $ to $ V_2 $ such that for all $ a $ and $ b $ in $ V_1 $, $ a $ and $ b $ are adjacent in $ G_1 $ iff $ f(a) $ and $ f(b) $ are adjacent in $ G_2 $. </li>
<li>In other words, when two simple graphs are isomorphic, there is a <strong>one-to-one correspondence</strong> between vertices of the two graphs that preserves the adjacency relationship.</li>
</ul>
<h4 id="how-to-determine">How to determine?<a class="headerlink" href="#how-to-determine" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>It is usually difficult to find an isomorphism <span class="arithmatex">\(f\)</span> since there are <span class="arithmatex">\(n!\)</span> possible <span class="arithmatex">\(1-1\)</span> correspondence between the two vertex sets with <span class="arithmatex">\(n\)</span> vertices.  </p>
</li>
<li>
<p>some properties (called <strong>invariants不变量</strong>) in the graphs may be used to show that they are not <strong>isomorphic</strong></p>
</li>
</ul>
<p><strong>Important invariants in isomorphic graphs</strong>: </p>
<ul>
<li>the number of vertices </li>
<li>the number of edges </li>
<li>the degrees of corresponding vertices  </li>
<li>if one is bipartite, the other must be </li>
<li>if one is complete, the other must be  </li>
<li>if one is a wheel, the other must be etc.</li>
</ul>
<h2 id="104-connectivity">10.4 Connectivity<a class="headerlink" href="#104-connectivity" title="Permanent link">&para;</a></h2>
<h3 id="1-paths">1. Paths<a class="headerlink" href="#1-paths" title="Permanent link">&para;</a></h3>
<p><strong>The concept of path</strong> : In <span class="arithmatex">\(G = (V, E)\)</span>, it is usually considered that starting from one vertex and terminating at another vertex by passing along some edges. </p>
<h4 id="definition-of-path-in-undirected-graph">Definition of path in undirected graph<a class="headerlink" href="#definition-of-path-in-undirected-graph" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Path of length <span class="arithmatex">\(n\)</span> from <span class="arithmatex">\(u\)</span> to <span class="arithmatex">\(v\)</span> in an undirected graph</strong>  </li>
<li>
<p>a sequence of <span class="arithmatex">\(n\)</span> edges <span class="arithmatex">\(e_1, ..., e_n\)</span> for which there exists a sequence <span class="arithmatex">\(x_0=u, x_1, ..., x_{n-1}, x_n=v\)</span> such that <span class="arithmatex">\(e_i\)</span> has endpoints <span class="arithmatex">\(x_{i-1}\)</span> and $ x_{i}$  </p>
</li>
<li>
<p>When the graph is simple, we denote this path by its vertex sequence <span class="arithmatex">\(x_0, x_1, ..., x_{n-1}, x_n\)</span> </p>
</li>
<li><strong>Circuit</strong> : if the path begins and ends with the same vertex </li>
<li>The path or circuit is said to <strong>pass through</strong> the vertices <span class="arithmatex">\(x_0, x_1, ..., x_{n-1}, x_n\)</span>  or <strong>traverse</strong> the edges <span class="arithmatex">\(e_1, ..., e_n\)</span> </li>
<li><strong>Simple path/circuit</strong> : if it does not contain the same edge more than once</li>
</ul>
<h4 id="definition-of-path-in-directed-graph">Definition of path in directed graph<a class="headerlink" href="#definition-of-path-in-directed-graph" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>path of length <span class="arithmatex">\(n\)</span> from <span class="arithmatex">\(u\)</span> to <span class="arithmatex">\(v\)</span> in a directed graph</strong>  </li>
<li>
<p>a sequence of edges <span class="arithmatex">\(e_1, ..., e_n\)</span> such that <span class="arithmatex">\(e_1\)</span> is associated with <span class="arithmatex">\((x_0,x_1),e_2,\dots\)</span></p>
</li>
<li>
<p>When there are no multiple edges in the directed graph, this path is denoted by its vertex sequence <span class="arithmatex">\(x_0, x_1, ..., x_{n-1}, x_n\)</span> </p>
</li>
<li>
<p><strong>circuit or cycle</strong>  </p>
</li>
<li>
<p>if the path begins and ends with the same vertex </p>
</li>
<li>
<p><strong>simple path/circuit</strong>  </p>
</li>
<li>if it does not contain the same edge more than once</li>
</ul>
<h3 id="2-connectedness-in-undirected-graphs">2. Connectedness in undirected graphs<a class="headerlink" href="#2-connectedness-in-undirected-graphs" title="Permanent link">&para;</a></h3>
<p><strong>Definition</strong></p>
<ul>
<li>An undirected graph is <strong>connected联通的</strong> : if there is a path between <strong>every pair</strong> of distinct vertices </li>
<li>An undirected graph is <strong>disconnected不连通的</strong> : the graph is not connected </li>
<li><strong>Disconnect</strong> a graph: remove vertices or edges, or both, to produce a disconnected subgraph. </li>
</ul>
<p><strong>【Theorem 1】</strong>There is a simple path between every pair of distinct vertices of a connected undirected graph. </p>
<p><strong>Connected Components连通分量</strong> : The maximally connected subgraphs of <span class="arithmatex">\(G\)</span> are called the <strong>connected components</strong> or just the <strong>components</strong>. </p>
<h3 id="3-how-connected-is-a-graph">3. How connected is a graph?<a class="headerlink" href="#3-how-connected-is-a-graph" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>cut vertex割点</strong> (or articulation point) </li>
<li>if removing a vertex and all edges incident with it results in <strong>more connected components</strong> than in the original graph. </li>
<li><strong>cut edge割边</strong> or bridge </li>
<li>if removing a edge creates <strong>more components</strong></li>
<li><strong>nonseparable graphs不可分割图</strong></li>
<li>Connected graphs without cut vertices</li>
<li>Nonseparable graphs can be thought of as more connected than those with a cut vertex.</li>
</ul>
<h3 id="4-vertex-connectivity">4. Vertex connectivity<a class="headerlink" href="#4-vertex-connectivity" title="Permanent link">&para;</a></h3>
<blockquote>
<p>How to measure graph connectivity?</p>
<ul>
<li>based on the minimum number of vertices that can be removed to disconnect a graph</li>
</ul>
</blockquote>
<p><strong>Vertex cut, or separating set 点割集</strong>: a subset <span class="arithmatex">\(V’\)</span> of the vertex set <span class="arithmatex">\(V\)</span> of <span class="arithmatex">\(G=(V,E)\)</span> such that <span class="arithmatex">\(G-V’\)</span> is disconnected.</p>
<ul>
<li>Every connected graph except a complete graph has a vertex cut.</li>
</ul>
<p><strong>Vertex connectivity点连通度</strong> <span class="arithmatex">\(κ(G)\)</span> : the minimum number of vertices in a vertex cut. </p>
<ul>
<li>
<p><span class="arithmatex">\(0\leq κ(G) \leq n-1\)</span></p>
</li>
<li>
<p>$ κ(G) =0$ iff <span class="arithmatex">\(G\)</span> is disconnected or <span class="arithmatex">\(G=K_1\)</span></p>
</li>
<li>
<p>$ κ(G) =1$ iff <span class="arithmatex">\(G\)</span> is connected with cut vertices or <span class="arithmatex">\(G=K_2\)</span></p>
</li>
<li>
<p>$ κ(G) =n-1$ iff <span class="arithmatex">\(G\)</span> is complete</p>
</li>
</ul>
<blockquote>
<p><span class="arithmatex">\(K_n\)</span> denotes a complete graph which has <span class="arithmatex">\(n\)</span> nodes</p>
</blockquote>
<p>A graph is <strong>K-connected</strong> (or k-vertex-connected ), if <span class="arithmatex">\(κ(G)≥K\)</span></p>
<h3 id="5-edge-connectivity">5. Edge connectivity<a class="headerlink" href="#5-edge-connectivity" title="Permanent link">&para;</a></h3>
<p><strong>edge cut边割集</strong>: a set of edges <span class="arithmatex">\(E’\)</span>  is called an edge cut of <span class="arithmatex">\(G\)</span> if the subgraph <span class="arithmatex">\(G-E’\)</span> is disconnected.</p>
<p><strong>edge connectivity边连通度</strong> <span class="arithmatex">\(λ(G)\)</span> : the minimum number of edges in an edge cut of <span class="arithmatex">\(G\)</span>.</p>
<ul>
<li><span class="arithmatex">\(0\leq λ(G) \leq n-1\)</span> if <span class="arithmatex">\(G\)</span> has <span class="arithmatex">\(n\)</span> vertices</li>
<li><span class="arithmatex">\(λ(G)=0\)</span> if <span class="arithmatex">\(G\)</span> is disconnected or <span class="arithmatex">\(G\)</span> is a graph consisting of a single vertice</li>
<li><span class="arithmatex">\(λ(G)=n-1\)</span> iff <span class="arithmatex">\(G=K_n\)</span></li>
</ul>
<p><strong>关于点连通度和边连通度的不等式</strong></p>
<ul>
<li>When <span class="arithmatex">\(G=(V,E)\)</span> is a noncomplete connected graph with at least three vertices <span class="arithmatex">\(κ(G)≤λ(G)≤min_{v \in V}deg(v)\)</span></li>
</ul>
<h3 id="6-connectedness-in-directed-graphs">6. Connectedness in directed graphs<a class="headerlink" href="#6-connectedness-in-directed-graphs" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>strongly connected</strong> </li>
<li>
<p>if there is a path from <span class="arithmatex">\(a\)</span> to <span class="arithmatex">\(b\)</span> and from <span class="arithmatex">\(b\)</span> to <span class="arithmatex">\(a\)</span> for <strong>all</strong> vertices <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> in the graph.   </p>
</li>
<li>
<p><strong>weakly connected</strong> </p>
</li>
<li>if the underlying undirected graph is connected</li>
<li><strong>strong components of a directed graph</strong></li>
<li>For directed graph, the maximal strongly connected subgraphs are called <strong>the strongly connected components强连通分量</strong> or just <strong>the strong components</strong></li>
</ul>
<blockquote>
<p>A weakly connected directed graph with <span class="arithmatex">\(deg^+(v)=deg^-(v)\)</span> for all vertices <span class="arithmatex">\(v\)</span> is strongly connected.</p>
</blockquote>
<h3 id="7-paths-and-isomorphism">7. Paths and Isomorphism<a class="headerlink" href="#7-paths-and-isomorphism" title="Permanent link">&para;</a></h3>
<ul>
<li>Some other graph invariants involving path  </li>
<li>Two graphs are <strong>isomorphic</strong> only if they have <u>simple circuits of the same length</u>.  </li>
<li>
<p>Two graphs are <strong>isomorphic</strong> only if they contain paths that go through vertices so that the corresponding vertices in the two graphs have the same degree.  </p>
</li>
<li>
<p>We can also use paths to find mapping that are potential isomorphisms</p>
</li>
</ul>
<h3 id="8-counting-paths-between-vertices">8. Counting paths between vertices<a class="headerlink" href="#8-counting-paths-between-vertices" title="Permanent link">&para;</a></h3>
<p><strong>【 Theorem 2】</strong> The number of different paths of length <span class="arithmatex">\(r\)</span> from <span class="arithmatex">\(v_i\)</span> to <span class="arithmatex">\(v_j\)</span> is equal to the <span class="arithmatex">\((i, j)th\)</span> entry of <span class="arithmatex">\(A^r\)</span>, where <span class="arithmatex">\(A\)</span> is the adjacency matrix representing the graph consisting of vertices <span class="arithmatex">\(v_1, v_2, . . . v_n\)</span>.</p>
<h2 id="105-euler-and-hamilton-paths">10.5 Euler and Hamilton Paths<a class="headerlink" href="#105-euler-and-hamilton-paths" title="Permanent link">&para;</a></h2>
<h3 id="1-euler-paths-and-circuits">1. Euler Paths and Circuits<a class="headerlink" href="#1-euler-paths-and-circuits" title="Permanent link">&para;</a></h3>
<ul>
<li><mark><strong>Euler Path 欧拉路</strong></mark>: a simple path containing every edge of <span class="arithmatex">\(G\)</span> </li>
<li><mark><strong>Euler Circuit 欧拉环</strong></mark>: a simple circuit containing every edge of <span class="arithmatex">\(G\)</span> </li>
<li><mark><strong>Euler Graph 欧拉图</strong></mark>: A graph contains an Euler circuit</li>
</ul>
<p><strong>【Theorem 1】</strong> A connected multigraph has an Euler circuit if and only if each of its vertices has <mark><strong>even</strong> degree</mark>.</p>
<p><strong>【Theorem 2】</strong> A connected multigraph has an Euler path but not an Euler circuit if and only if it has <mark>exactly <strong>two</strong> vertices of odd degree</mark>.</p>
<h4 id="euler-circuits-and-paths-in-directed-graphs">Euler circuits and paths in directed graphs<a class="headerlink" href="#euler-circuits-and-paths-in-directed-graphs" title="Permanent link">&para;</a></h4>
<p>A directed multigraph having no isolated vertices has an <strong>Euler circuit</strong> if and only if </p>
<ul>
<li>the graph is <strong>weakly connected</strong> </li>
<li>the <u>in-degree and out-degree</u> of each vertex are <strong>equal</strong>.</li>
</ul>
<p>A directed multigraph having no isolated vertices has an <strong>Euler path</strong> but not an Euler circuit if and only if </p>
<ul>
<li>the graph is <strong>weakly connected</strong> </li>
<li>the <u>in-degree and out-degree</u> of each vertex are <strong>equal</strong> for all but two vertices, one that has in-degree <span class="arithmatex">\(1\)</span> larger than its out degree and the other that has out-degree <span class="arithmatex">\(1\)</span> larger than its in-degree.</li>
</ul>
<h3 id="2-hamiltons-paths-and-circuits">2. Hamilton’s paths and Circuits<a class="headerlink" href="#2-hamiltons-paths-and-circuits" title="Permanent link">&para;</a></h3>
<ul>
<li><mark><strong>Hamilton path 哈密顿路</strong></mark>: a path which visits every vertex in <span class="arithmatex">\(G\)</span> <strong>exactly once</strong> </li>
<li><mark><strong>Hamilton circuit 哈密顿环 (or Hamilton cycle)</strong></mark>: a cycle which visits every vertex <strong>exactly once</strong>, except for the first vertex, which is also visited at the end of the cycle. </li>
<li><mark><strong>Hamilton graph 哈密顿图</strong></mark>: a connected graph <span class="arithmatex">\(G\)</span> has a Hamilton circuit</li>
</ul>
<p><strong>【 Theorem 3】</strong> <mark><strong>DIRAC' THEOREM 狄拉克定理</strong></mark>: If <span class="arithmatex">\(G\)</span> is a <u>simple graph</u> with <span class="arithmatex">\(n\)</span> vertices <span class="arithmatex">\(n \geq 3\)</span> such that the degree of every vertex in <span class="arithmatex">\(G\)</span> is at least <span class="arithmatex">\(n/2\)</span>, then <span class="arithmatex">\(G\)</span> has a Hamilton circuit.  </p>
<p><strong>【 Theorem 4】</strong> <mark><strong>ORE' THEOREM 奥尔定理</strong></mark>: If <span class="arithmatex">\(G\)</span> is a simple graph with <span class="arithmatex">\(n\)</span> vertices with <span class="arithmatex">\(n\geq3\)</span> such that <span class="arithmatex">\(deg(u)+deg(v) \geq n\)</span> for every pair of <strong>nonadjacent vertices</strong> <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span> in <span class="arithmatex">\(G\)</span>, then <span class="arithmatex">\(G\)</span> has a Hamilton circuit.</p>
<p><strong>Another important necessary condition</strong>:</p>
<ul>
<li>For any nonempty subset <span class="arithmatex">\(S\)</span> of set <span class="arithmatex">\(V\)</span>, the number of connected components in <span class="arithmatex">\(G-S\)</span> <span class="arithmatex">\(\leq|S|\)</span></li>
</ul>
<h2 id="106-shortest-path-problems">10.6 Shortest Path Problems<a class="headerlink" href="#106-shortest-path-problems" title="Permanent link">&para;</a></h2>
<ul>
<li>Weighted graph 带权图:  <span class="arithmatex">\(G = (V,E,W)\)</span> </li>
<li>the length of a path in a weighted graph: The <strong>sum</strong> of the weights of the edges of this path</li>
</ul>
<h3 id="a-shortest-path-algorithm">A Shortest path Algorithm<a class="headerlink" href="#a-shortest-path-algorithm" title="Permanent link">&para;</a></h3>
<p><span class="arithmatex">\(G=(V,E,W)\)</span> is a weighted graph, where <span class="arithmatex">\(w(x,y)\)</span> is the weight of edge associated vertices <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(y\)</span>  (if <span class="arithmatex">\((x,y)\notin E,w(x,y)=\infty\)</span> ), <span class="arithmatex">\(a,z\in V\)</span> , find the shortest path between <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(z\)</span>.</p>
<h4 id="dijkstras-algorithm"><strong>Dijkstra’s Algorithm</strong><a class="headerlink" href="#dijkstras-algorithm" title="Permanent link">&para;</a></h4>
<p>Let <span class="arithmatex">\(S_k\)</span> denote the set of vertices after <span class="arithmatex">\(k\)</span> iterations of <strong>labeling procedure</strong>. </p>
<ol>
<li>Initialization. Label <span class="arithmatex">\(a\)</span> with <span class="arithmatex">\(0\)</span> and other with <span class="arithmatex">\(∞\)</span>, i.e. <span class="arithmatex">\(L_0(a)=0\)</span>, and <span class="arithmatex">\(L_0(v)= ∞\)</span> and <span class="arithmatex">\(S_0=φ\)</span></li>
<li>Form <span class="arithmatex">\(S_k\)</span>. The set <span class="arithmatex">\(S_k\)</span> is formed from <span class="arithmatex">\(S_{k-1}\)</span> by adding a vertex <span class="arithmatex">\(u\)</span> not in <span class="arithmatex">\(S_{k-1}\)</span> with the smallest label.  </li>
<li>Update the labels of all vertices not in <span class="arithmatex">\(S_k\)</span> , so that <span class="arithmatex">\(L_k(v)\)</span>, the label of the vertex <span class="arithmatex">\(v\)</span> at the <span class="arithmatex">\(k_{th}\)</span> stage, is the length of the shortest path from <span class="arithmatex">\(a\)</span> to <span class="arithmatex">\(v\)</span> that containing vertices only in <span class="arithmatex">\(S_k\)</span></li>
<li>
<p>Step <span class="arithmatex">\(2\)</span> and <span class="arithmatex">\(3\)</span> is iterated by successively adding vertices to the distinguished set the until <span class="arithmatex">\(z\)</span> is added.</p>
</li>
<li>
<p>Update the labels of all vertices not in <span class="arithmatex">\(S_k\)</span> : <span class="arithmatex">\(L_k(v)=min\{L_{k-1}(v), L_{k-1}(u)+w(u,v)\}\)</span></p>
</li>
</ol>
<p><strong>【Theorem 1】</strong>Dijkstra’s algorithm finds the length of a shortest path between two vertices in a connected simple undirected weighted graph.</p>
<p><strong>【Theorem 2】</strong>Dijkstra’s algorithm uses <span class="arithmatex">\(O(n^2 )\)</span> operations (additions and comparisons) to find the length of the shortest path between two vertices in a connected simple undirected weighted graph.</p>
<h4 id="the-traveling-salesperson-problem">The Traveling Salesperson Problem<a class="headerlink" href="#the-traveling-salesperson-problem" title="Permanent link">&para;</a></h4>
<p><strong>Solving TSP</strong></p>
<p>The most straightforward one:  </p>
<ul>
<li>Examine all possible Hamilton circuits and select one of  minimum total length. How many are there different length of Hamilton circuits in a complete graph with n vertices?</li>
<li><span class="arithmatex">\((n-1)!/2\)</span></li>
</ul>
<p>Approximation algorithm:</p>
<ul>
<li>do not necessary produce the exact solution </li>
<li>to produce a solution that is close to an exact solution</li>
</ul>
<h2 id="107-planar-graphs">10.7 Planar Graphs<a class="headerlink" href="#107-planar-graphs" title="Permanent link">&para;</a></h2>
<p>【Definition】A graph is called <strong>planar平面的</strong> if it can be drawn in the plane without any edges crossing. </p>
<ul>
<li>Such a drawing is called a <strong>planar representation平面表示法</strong> of the graph.</li>
</ul>
<h3 id="1-some-terminologies">1. Some terminologies:<a class="headerlink" href="#1-some-terminologies" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Region</strong>: a part of the plane completely disconnected off from other parts of the plane by the edges of the graph. </p>
</li>
<li>
<p>Bounded region  </p>
</li>
<li>Unbounded region </li>
</ul>
<p>Note: There is <strong>one unbounded region</strong> in a planar graph. </p>
<ul>
<li>
<p><strong>the boundary of region</strong> </p>
</li>
<li>
<p><strong>the Degree of Region</strong> <span class="arithmatex">\(R\)</span> (<span class="arithmatex">\(Deg(R)\)</span>): the number of the edges which surround <span class="arithmatex">\(R\)</span>, suppose <span class="arithmatex">\(R\)</span> is a region of a connected planar simple graph </p>
</li>
<li>
<p><strong>adjacent regions</strong>: two regions with a common border  </p>
</li>
<li>
<p>If <span class="arithmatex">\(e\)</span> is not a cut edge, then it must be the <strong>common border</strong> of two regions</p>
</li>
</ul>
<h3 id="2-eulers-formula">2. Euler’s Formula<a class="headerlink" href="#2-eulers-formula" title="Permanent link">&para;</a></h3>
<h4 id="theorem-1-eulers-formula"><strong>【Theorem 1】</strong> <strong><mark>Euler’s formula</mark></strong><a class="headerlink" href="#theorem-1-eulers-formula" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>Let <span class="arithmatex">\(G\)</span> be a <strong>connected planar simple graph</strong> with <span class="arithmatex">\(e\)</span> edges and <span class="arithmatex">\(v\)</span> vertices. Let <span class="arithmatex">\(r\)</span> be the number of regions in a planar representation of <span class="arithmatex">\(G\)</span>. Then <mark><span class="arithmatex">\(r=e-v+2\)</span></mark>.</p>
</li>
<li>
<p>For <strong>Unconnected simple planar graph</strong>: Suppose that a planar graph <span class="arithmatex">\(G\)</span> has <span class="arithmatex">\(k\)</span> connected components, <span class="arithmatex">\(e\)</span> edges, and <span class="arithmatex">\(v\)</span> vertices. Let <span class="arithmatex">\(r\)</span> be the number of regions in a planar representation of <span class="arithmatex">\(G\)</span>. Then <mark><span class="arithmatex">\(r=e-v+k+1\)</span></mark>.</p>
</li>
</ul>
<p><strong>【Corollary 1】</strong>If <span class="arithmatex">\(G\)</span> is a <strong>connected</strong> planar simple graph with <span class="arithmatex">\(e\)</span> edges and <span class="arithmatex">\(v\)</span> vertices where <span class="arithmatex">\(v≥3\)</span>, then <span class="arithmatex">\(e≤3v-6\)</span>. </p>
<blockquote>
<p>显然 <span class="arithmatex">\(deg(R) ≥ 3\)</span>, 并且 <span class="arithmatex">\(2e=\sum_{all \space regions \space R}degR \geq 3r\)</span>, 结合欧拉公式可证明</p>
</blockquote>
<p><strong>【Corollary 2】</strong>If a <strong>connected</strong> planar simple graph has <span class="arithmatex">\(e\)</span> edges and <span class="arithmatex">\(v\)</span> vertices with <span class="arithmatex">\(v≥3\)</span> and no circuits of length <span class="arithmatex">\(3\)</span>, then <span class="arithmatex">\(e ≤2v-4\)</span>.</p>
<blockquote>
<p>显然 <span class="arithmatex">\(deg(R) ≥ 4\)</span>, 并且 <span class="arithmatex">\(2e=\sum_{all \space regions \space R}degR \geq 4r\)</span>, 结合欧拉公式可证明</p>
</blockquote>
<p><strong>【Corollary 3】</strong>If <span class="arithmatex">\(G\)</span> is a <strong>connected</strong> planar simple graph, then <span class="arithmatex">\(G\)</span> has a vertex of degree not exceeding <strong>five</strong>.</p>
<blockquote>
<p>By Corollary 1 , we know that <span class="arithmatex">\(e≤3v-6\)</span> , so <span class="arithmatex">\(2e≤6v-12\)</span>. If the degree of every vertex were at least six, then <span class="arithmatex">\(2e≥6v\)</span>, there is no solution</p>
</blockquote>
<h3 id="3-kuratowskis-theorem">3. Kuratowski's Theorem<a class="headerlink" href="#3-kuratowskis-theorem" title="Permanent link">&para;</a></h3>
<p><strong>Elementary subdivision初等细分</strong>: If a graph is planar, so will be any graph obtained by removing an edge <span class="arithmatex">\(\{u, v\}\)</span> and adding a new vertex <span class="arithmatex">\(w\)</span> together with edges <span class="arithmatex">\(\{u,w\}\)</span> and <span class="arithmatex">\(\{w,v\}\)</span>.</p>
<p><img alt="image-20250523222110861" src="images/image-20250523222110861.png" /></p>
<p><strong>homeomorphic同胚的</strong> : the graph <span class="arithmatex">\(G_1=(V_1,E_1)\)</span> and <span class="arithmatex">\(G_2=(V_2,E_2)\)</span> are called <strong>homeomorphic</strong> if they can be obtained from the same graph by a sequence of elementary subdivision.</p>
<p><strong>【Theorem 2】</strong> <mark>A graph is nonplanar if and only if it contains a subgraph <strong>homeomorphic</strong> to <span class="arithmatex">\(K_{3,3}\space or\space K_5\)</span>.</mark></p>
<h2 id="108-graph-coloring">10.8 Graph Coloring<a class="headerlink" href="#108-graph-coloring" title="Permanent link">&para;</a></h2>
<p>the <strong>dual graph对偶图</strong> of the map </p>
<ul>
<li>Each region of the map is represented by a vertex.  </li>
<li>Edge connect two vertices if the regions represented by these vertices have a common border.  </li>
<li>Two regions that touch at only one point are not considered  adjacent.</li>
</ul>
<p><img alt="image-20250531161419396" src="images/image-20250531161419396.png" /></p>
<h3 id="the-chromatic-numbers-of-a-graph">The chromatic numbers of a graph<a class="headerlink" href="#the-chromatic-numbers-of-a-graph" title="Permanent link">&para;</a></h3>
<p>Terminologies: </p>
<ul>
<li><strong>Coloring</strong>: the assignment of a color to each vertex of the graph so that no two adjacent vertices  are assigned the same color. </li>
<li><strong>chromatic number <span class="arithmatex">\(χ(G)\)</span></strong>: the least number of colors needed for a coloring of this graph</li>
</ul>
<p><strong>The chromatic numbers of some simple graphs</strong></p>
<ol>
<li>
<p>The graph <span class="arithmatex">\(G\)</span> contains only some isolated vertices. <span class="arithmatex">\(χ(G)=1\)</span></p>
</li>
<li>
<p>The graph <span class="arithmatex">\(G\)</span> is a path containing no circuit. <span class="arithmatex">\(χ(G)=2\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(C_n(n \geq 3)\)</span> , $<span class="arithmatex">\(\begin{cases} \chi(C_n) = 2 &amp; \text{if } n \text{ is even} \\ \chi(G) = 3 &amp; \text{if } n \text{ is odd} \end{cases}\)</span>$</p>
</li>
</ol>
<p><img src="images/image-20250531162954522.png" alt="image-20250531162954522"  /></p>
<ol>
<li><span class="arithmatex">\(K_n\)</span></li>
</ol>
<p><span class="arithmatex">\(χ(K_n)=n\)</span>  <span class="arithmatex">\(χ(K_n-e)=n-1\)</span> <img src="images/image-20250531162921690.png" alt="image-20250531162921690" style="zoom:50%;" /></p>
<ol>
<li><span class="arithmatex">\(K_{m,n}\)</span></li>
</ol>
<p><span class="arithmatex">\(χ(K_{m,n})=2\)</span> <img src="images/image-20250531162939223.png" alt="image-20250531162939223" style="zoom:50%;" /></p>
<h3 id="algorithm-for-coloring-simple-graphs">Algorithm for coloring simple graphs<a class="headerlink" href="#algorithm-for-coloring-simple-graphs" title="Permanent link">&para;</a></h3>
<p><img alt="image-20250531163157862" src="images/image-20250531163157862.png" /></p>
<p><strong>【 Theorem 1】</strong> <strong><mark>The Four Color Theorem</mark></strong> 
The chromatic number of a <strong>planar graph</strong> is <strong>no greater than four</strong>.</p>
<h1 id="ch11-trees">Ch11 Trees<a class="headerlink" href="#ch11-trees" title="Permanent link">&para;</a></h1>
<h2 id="111-introduction-to-trees">11.1 Introduction to Trees<a class="headerlink" href="#111-introduction-to-trees" title="Permanent link">&para;</a></h2>
<h3 id="1-tree">1. Tree<a class="headerlink" href="#1-tree" title="Permanent link">&para;</a></h3>
<p><strong>【Definition】</strong>: A tree is a <strong><u>connected undirected</u></strong> graph with <strong><u>no simple circuits</u></strong>.</p>
<ul>
<li><strong>Note</strong>: Any tree must be a simple graph. </li>
</ul>
<p><strong>【Definition】</strong>:  A <strong>forest</strong> is a graph that has no simple circuit, but is not connected. Each of the connected components in a forest is a tree. </p>
<p><strong>【Theorem 1】</strong>: An undirected graph is a tree if and only if there is a <strong>unique simple</strong> path between any two of its vertices.</p>
<h4 id="root-tree">Root tree<a class="headerlink" href="#root-tree" title="Permanent link">&para;</a></h4>
<p><strong>【Definition】</strong>: A <strong>rooted tree有根树</strong> is a tree in which one vertex has been designated as the root and every edge is directed away from the  root.</p>
<p><strong>【Definition】</strong>: A rooted tree is called a <strong>m-ary tree m叉树</strong> if every internal vertex has <strong>no more than</strong> <span class="arithmatex">\(m\)</span> children. </p>
<p><strong>【Definition】</strong>: A rooted tree is called a <strong>full m-ary tree 满m叉树</strong> if every internal vertex has <strong>exactly</strong> <span class="arithmatex">\(m\)</span> children. </p>
<p><strong>【Definition】</strong>: An <strong>ordered rooted tree</strong> is a rooted tree where the children of each internal vertex are ordered.</p>
<ul>
<li>In an ordered binary tree, the two possible children of a vertex are called the <strong>left child</strong> and the <strong>right child</strong>, if they exist. </li>
<li>The tree rooted at the left child is called the <strong>left subtree</strong>, and that rooted at the right child is called the <strong>right subtree</strong>.</li>
</ul>
<h4 id="rooted-tree-terminology">Rooted Tree Terminology<a class="headerlink" href="#rooted-tree-terminology" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Parent &amp; Child</strong></li>
</ul>
<p>The parent of a non-root vertex <span class="arithmatex">\(v\)</span> is the unique vertex <span class="arithmatex">\(u\)</span> with a directed edge from <span class="arithmatex">\(u\)</span> to <span class="arithmatex">\(v\)</span>.</p>
<ul>
<li><strong>Sibling</strong></li>
</ul>
<p>Vertices with the same parent are called <strong>siblings</strong>.</p>
<ul>
<li>
<p><strong>Ancestors &amp; Descendants</strong> </p>
</li>
<li>
<p>The <strong>ancestors of a non-root vertex</strong> are all the vertices in the path from root to this vertex.   </p>
</li>
<li>
<p>The <strong>descendants of vertex <span class="arithmatex">\(v\)</span></strong> are all the vertices that have <span class="arithmatex">\(v\)</span> as an ancestor.  </p>
</li>
<li>
<p><strong>Leaf</strong></p>
</li>
</ul>
<p>A vertex is called a <strong>leaf</strong> if it has no children.</p>
<ul>
<li><strong>Internal Vertex</strong> </li>
</ul>
<p>A vertex that have children is called an <strong>internal vertex</strong>.</p>
<ul>
<li><strong>Subtree</strong> </li>
</ul>
<p>The <strong>subtree</strong> at vertex <span class="arithmatex">\(v\)</span> is the subgraph of the tree consisting of vertex <span class="arithmatex">\(v\)</span> and its descendants and all edges incident to those descendants. </p>
<h3 id="2-properties-of-trees">2. Properties of Trees<a class="headerlink" href="#2-properties-of-trees" title="Permanent link">&para;</a></h3>
<p><strong>【Theorem 2】</strong> A tree with <span class="arithmatex">\(n\)</span> vertices has <span class="arithmatex">\(n-1\)</span> edges.</p>
<p><strong>【Theorem 3】</strong> A full <span class="arithmatex">\(m-ary\)</span> tree with <span class="arithmatex">\(i\)</span> internal vertices contains <span class="arithmatex">\(n=mi+1\)</span> vertices.</p>
<p><strong>【Theorem 4】</strong> A full <span class="arithmatex">\(m-ary\)</span> tree with </p>
<ul>
<li><span class="arithmatex">\(n\)</span> vertices has <span class="arithmatex">\(i=\frac{n-1}{m}\)</span> internal vertices and <span class="arithmatex">\(l=\frac{(m-1)n+1}{m}\)</span>  leaves </li>
<li><span class="arithmatex">\(i\)</span> internal vertices has <span class="arithmatex">\(n=mi+1\)</span> vertices and <span class="arithmatex">\(l=(m-1)i+1\)</span> leaves  </li>
<li><span class="arithmatex">\(l\)</span> leaves has <span class="arithmatex">\(n=\frac{ml-1}{m-1}\)</span> vertices and <span class="arithmatex">\(i=\frac{l-1}{m-1}\)</span> internal vertices</li>
</ul>
<p>The <strong>level层级</strong> of vertex <span class="arithmatex">\(v\)</span> in a rooted tree is the <strong>length</strong> of the unique path <u>from the root to <span class="arithmatex">\(v\)</span></u>.     </p>
<p>The <strong>height高度</strong> of a rooted tree is the <u>maximum of the levels</u> of its vertices. (<span class="arithmatex">\(\text{the height of root}=0\)</span>)</p>
<ul>
<li>A rooted <span class="arithmatex">\(m-ary\)</span> tree of height <span class="arithmatex">\(h\)</span> is called <strong>balanced平衡的</strong> if all its leaves are at levels <span class="arithmatex">\(h\)</span> or <span class="arithmatex">\(h-1\)</span>.</li>
</ul>
<p><strong>【Theorem 5】</strong>There are at most <span class="arithmatex">\(m^h\)</span> leaves in an <span class="arithmatex">\(m-ary\)</span> tree of height <span class="arithmatex">\(h\)</span>.</p>
<p><strong>【Corallary】</strong></p>
<ul>
<li>If an <span class="arithmatex">\(m-ary\)</span> tree of height $h $ has <span class="arithmatex">\(l\)</span> leaves, then <span class="arithmatex">\(h ≥ ⌈ log_m l ⌉\)</span>.</li>
<li>If the <span class="arithmatex">\(m-ary\)</span> tree is <strong>full and balanced</strong>, then <span class="arithmatex">\(h = ⌈ log_m l ⌉\)</span>.</li>
</ul>
<h2 id="112-applications-of-trees">11.2 Applications of Trees<a class="headerlink" href="#112-applications-of-trees" title="Permanent link">&para;</a></h2>
<h3 id="1-binary-search-trees">1. Binary Search Trees<a class="headerlink" href="#1-binary-search-trees" title="Permanent link">&para;</a></h3>
<ul>
<li>A binary search tree can be used to <strong>store item</strong>s in its vertices. It enables efficient searches.</li>
<li><strong>Binary search tree</strong>  </li>
<li>An ordered rooted binary tree </li>
<li>Each vertex contains a distinct <strong>key value</strong> </li>
<li>The key values in the tree can be compared using “greater than” and “less than”, and</li>
<li>The key value of each vertex in the tree is <strong>less than every key value in its right subtree</strong>, and <strong>greater than every key value in its left subtree</strong>.</li>
</ul>
<p><img src="images/image-20250531202859165.png" alt="image-20250531202859165" style="zoom:67%;" /></p>
<h3 id="2-decision-trees">2. Decision Trees<a class="headerlink" href="#2-decision-trees" title="Permanent link">&para;</a></h3>
<ul>
<li>Rooted trees can be used to model problems in which a series of decisions leads to a solution.  </li>
<li>A rooted tree in which each internal vertex corresponds to a decision, with a subtree at these vertices for each possible outcome of the decision, is called a <strong>decision tree决策树</strong>.</li>
</ul>
<p><img src="images/image-20250531203145819.png" alt="image-20250531203145819" style="zoom:60%;" /></p>
<h3 id="3-prefix-codes">3. Prefix Codes<a class="headerlink" href="#3-prefix-codes" title="Permanent link">&para;</a></h3>
<ul>
<li>To ensure that no bit string corresponds to more than one sequence  of letters, the bit string for a letter must never occur as the first  part of the bit string for another letter. Codes with this property are called <strong>prefix codes前缀码</strong>.</li>
</ul>
<h4 id="huffman-coding">Huffman Coding<a class="headerlink" href="#huffman-coding" title="Permanent link">&para;</a></h4>
<p><img src="images/image-20250601104000549.png" alt="image-20250601104000549" style="zoom:80%;" /></p>
<ul>
<li><strong>Huffman Tree 哈夫曼树</strong></li>
</ul>
<blockquote>
<p>流程：</p>
<ul>
<li>
<p>初始状态下，有一片森林，其中每棵树只有一个表示不同字符的节点</p>
</li>
<li>
<p>每一步中，我们挑选权重 ( 频率 ) 最小的两棵树，组成新的树：</p>
</li>
<li>
<p>引入一个新的根</p>
</li>
<li>将<strong>权重较大</strong>的树作为<strong>左子树</strong></li>
<li>将权重较小的树作为<strong>右子树</strong></li>
<li>新的树的权重为 2 棵树的权重和</li>
</ul>
<p>然后将新的树放回原来的森林中</p>
<ul>
<li>直到只剩下一棵树时为止</li>
</ul>
</blockquote>
<p><img alt="image-20250603214511014" src="images/image-20250603214511014.png" /></p>
<h2 id="113-tree-traversal">11.3 Tree Traversal<a class="headerlink" href="#113-tree-traversal" title="Permanent link">&para;</a></h2>
<ul>
<li>A traversal algorithm is a procedure for <strong>systematically visiting every vertex</strong> of an ordered rooted tree.   </li>
<li>Tree traversals are defined recursively.  </li>
</ul>
<h3 id="1-preorder-traversal">1. Preorder Traversal<a class="headerlink" href="#1-preorder-traversal" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>procedure  preorder (T: ordered rooted tree)
r := root of T
list r
for each child c of r from left to 
right
 T(c) := subtree with c as root
 preorder(T(c))
</code></pre></div>
<h3 id="2-inorder-traversal">2. Inorder Traversal<a class="headerlink" href="#2-inorder-traversal" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>procedure  inorder (T: ordered rooted tree)
r := root of T
if r is a leaf then list r
else
    l := first child of r from left to right
    T(l) := subtree with l as its root
    inorder(T(l))
    list(r)
    for each child c of r from left to right
       T(c) := subtree with c as root
       inorder(T(c))
</code></pre></div>
<h3 id="3-postorder-traversal">3. Postorder Traversal<a class="headerlink" href="#3-postorder-traversal" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>procedure  postordered (T: ordered rooted tree)
r := root of T
for each child c of r from left to right
   T(c) := subtree with c as root
   postorder(T(c))
list r
</code></pre></div>
<h3 id="expression-trees">Expression Trees<a class="headerlink" href="#expression-trees" title="Permanent link">&para;</a></h3>
<p>A Binary Expression Tree is a special kind of binary tree in which: </p>
<ul>
<li>Each <strong>leaf node</strong> contains a single operand, </li>
<li>Each <strong>nonleaf node</strong> contains a single operator, and </li>
<li>The left and right subtrees of an operator node represent <strong>subexpressions</strong> that must be evaluated <strong>before</strong> applying the operator at the root of the subtree.</li>
</ul>
<p><img src="images/image-20250601105129898.png" alt="image-20250601105129898" style="zoom:80%;" /></p>
<ul>
<li><strong>Infix Form中缀式</strong>: An <strong>inorder traversal</strong> of the tree representing an expression produces the original expression when parentheses are included except for unary operations, which now immediately follow their operands. </li>
<li>infix form: <span class="arithmatex">\(3*ln(x+1)+a/x \uparrow 2\)</span></li>
<li><strong>Prefix Form前缀式</strong>: The expression obtained by an preorder traversal of the binary tree is said to be in prefix form ( <strong>Polish notation波兰表示法</strong> ).</li>
<li>prefix form: <span class="arithmatex">\(+*3ln+x1/a\uparrow x2\)</span></li>
<li><strong>Postfix Form后缀式</strong>: The expression obtained by an postorder traversal of the binary tree is said to be in postfix form ( <strong>reverse Polish notation逆波兰表示法</strong> ).</li>
<li>postfix form: <span class="arithmatex">\(3x1+ln*ax2\uparrow /+\)</span></li>
</ul>
<h2 id="114-spanning-trees">11.4 Spanning Trees<a class="headerlink" href="#114-spanning-trees" title="Permanent link">&para;</a></h2>
<p>【Definition1】Let <span class="arithmatex">\(G\)</span> be a simple graph. A <strong>spanning tree生成树</strong> of <span class="arithmatex">\(G\)</span> is a subgraph of <span class="arithmatex">\(G\)</span> that is <strong>a tree containing every vertex of <span class="arithmatex">\(G\)</span></strong>.</p>
<p>【Theorem 1】A simple graph is connected if and only if it has a spanning tree.</p>
<h3 id="depth-first-search">Depth-first search<a class="headerlink" href="#depth-first-search" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Depth-first search深度优先算法</strong> (also called <strong>backtracking回溯</strong>) -- this procedure forms a rooted tree, and the underlying undirected graph is a spanning tree. </p>
</li>
<li>
<p>先在图中任意选取一个顶点作为根节点</p>
</li>
<li>从根节点出发，连续添加顶点和边，其中新增的边一定与最后添加的顶点相关联，且新添的顶点尚不在路径中，尽可能地往下这样做</li>
<li>当访问完所有顶点时，我们可以得到一棵生成树</li>
<li>否则 ( 遇到“死胡同”)，返回到路径中倒数第二个顶点，若有可能，从该顶点出发，按照上面的步骤重新寻找新的路径 ( 要找未被访问过的顶点 )。如果找完所有可能，再返回上一个顶点，再寻找新的路径，直至所有顶点均被访问过</li>
</ul>
<div class="highlight"><pre><span></span><code>procedure DFS(G: connected graph with vertices v1, v2, …, vn)
T := tree consisting only of the vertex v1   
visit(v1)

procedure visit(v: vertex of G)
for each vertex w adjacent to v and not yet in T
  add vertex w and edge {v,w} to T
  visit(w)
</code></pre></div>
<h3 id="breadth-first-search">Breadth-first search<a class="headerlink" href="#breadth-first-search" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Breadth-first search宽度优先算法</strong></p>
</li>
<li>
<p>先在图中任意选取一个顶点作为根节点</p>
</li>
<li>将所有与根节点相邻的顶点添加至树内，对它们任意排序，这些顶点因而成为生成树中层级为 1 的节点，</li>
<li>对于层级为 1 的所有节点，按顺序依次访问所有与这些顶点关联的边上的另一个顶点，且保证不会产生简单环，对得到的顶点进行任意排序</li>
<li>这样，我们得到层级为 1 的节点的所有孩子，它们构成层级为 2 的节点</li>
<li>如此往复，直至所有顶点被添加至树内</li>
</ul>
<div class="highlight"><pre><span></span><code>procedure BFS(G: connected graph with vertices v1, v2, …, vn)
T := tree consisting only of the vertex v1   
L := empty list visit(v1)
put v1 in the list L of unprocessed vertices
while L is not empty
  remove the first vertex, v, from L
  for each neighbor w of v 
    if w is not in L and not in T then
       add w to the end of the list L
       add w and edge {v,w} to T
</code></pre></div>
<h3 id="backtracking-scheme">Backtracking scheme<a class="headerlink" href="#backtracking-scheme" title="Permanent link">&para;</a></h3>
<p><img alt="image-20250604104545179" src="images/image-20250604104545179.png" /></p>
<h2 id="115-minimum-spanning-trees">11.5 Minimum Spanning Trees<a class="headerlink" href="#115-minimum-spanning-trees" title="Permanent link">&para;</a></h2>
<p>【Definition1】A minimum spanning tree in a connected weighted graph is a spanning tree that has the smallest possible sum of weights of its edges.</p>
<h3 id="prims-algorithm">Prim's algorithm<a class="headerlink" href="#prims-algorithm" title="Permanent link">&para;</a></h3>
<ul>
<li>思想：在图中剩余的边里，将与树中节点有关联的权重最小的边加到树中</li>
</ul>
<div class="highlight"><pre><span></span><code>Procedure Prim (G: weighted connected undirected graph with n vertices)
T:= a minimum-weight edge
for i:= 1 to n-2
begin
  e:= an edge of minimum weight incident to a vertex in   
      T and not forming a simple circuit in T if added to T.
  T:= T with e added
end {T is a minimum spanning tree of G}
</code></pre></div>
<h3 id="kruskals-algorithm">Kruskal's algorithm<a class="headerlink" href="#kruskals-algorithm" title="Permanent link">&para;</a></h3>
<ul>
<li>挑选当前图中剩余的边里权重最小的边，且不会产生环</li>
</ul>
<div class="highlight"><pre><span></span><code>procedure Kruskal (G: weighted connected undirected graph with n vertices)
T:= empty graph
for i:= 1 to n-1
begin
  e:= any edge in G with smallest weight that does not 
      form a simple circuit when added to T
  T:= T with e added
end {T is a minimum spanning tree of G}
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["header.autohide", "content.math", "content.action.edit", "content.action.view", "content.code.copy", "content.code.annotate", "content.tooltips", "navigation.footer", "navigation.indexes", "navigation.path", "navigation.prune", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.tracking", "search.share", "search.suggest", "search.highlight", "toc.follow"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
      
    
  </body>
</html>