# C程理论笔记
!!!info intro 
     2024.12: 

    - C 程的理论考试知识点非常多。这还是我第一次用 markdown 整理笔记，可能有些小问题 QwQ
 
    2025.12:

    - 今年报名了学长组，好多同学来私信问我如何复习 C 程，翻资料时找到了这份笔记，决定修改一下发出来，如有错误请指正！

## 1. 一些定义

1. 变量初始化的含义，就是在定义变量时**对变量赋值**。  
2. 缓冲文件系统的文件缓冲区位于**内存数据区**中。
3. 在对数组全部元素赋初值时，**不可以**省略**列数**，但**能**省略**行数**。
4. 数组初始化时，如果初始化列表中的初始值个数小于数组的元素个数，那么剩余的数组元素会自动被初始化为 `0`
5. C 语言的“**字符串常量**”格式为 `"1 c*z&^/64"` (**双引号**)
6. `int a[10]`, 定义后数组 a 的地址**不能更改**，`a++`，`a--` 是非法的
   - 二维数组**无法**退化为二级指针
   - 数组名**不能**被重新赋值（指向地址）
7. 自定义函数时，数组名作为形参 `fun (int a[ ]);`，编译时自动转化为指针 `fun (int *a);`
8. 函数的定义**不能嵌套**, 即函数的定义不可完整地包含另一个函数的定义

## 2. 转义字符

```c
char s[] = "\101\102"; //使用八进制表示法
char s[] = "\x41\x42"; //使用十六进制表示法
char s[] = "AB" //正常的表示法
```

以上代码等价，此外在计算 `sizeof () ` 时都算作<u>两个字符</u>

| 转义字符 | 描述        |
| ---- | --------- |
| \'   | 单引号       |
| \"   | 双引号       |
| \\   | 反斜杠       |
| \n   | 换行符       |
| \t   | 水平制表符     |
| \r   | 回车符       |
| \b   | 退格符       |
| \f   | 换页符       |
| \a   | 警告（响铃）    |
| \v   | 垂直制表符     |
| \?   | 问号        |
| \0   | 空字符       |
| \xhh | 十六进制表示的字符 |
| \ooo | 八进制表示的字符  |

!!!note
    - `\` 后最多接三个数字，使用**八进制**表示一个字节，且遇到 0-7 范围之外的数字会结束当前字节，比如 `\101` 也表示 `A`，而 `\08` 因为 8 超过了八进制范围，所以这是两个字符放到了一个单引号里，不是正确的用法，如果写成字符串，则 `\08` 表示两个字符；
    -  `\x ` 后面接 0-9、A-F 字符通过十六进制来表示一个字符。不过并**不会有长度限制**，比如 `\x 00000041 ` 也是一个字符，同样遇到范围外的字符就结束。
    - 用八进制和十六进制表示的数大小**不超过 255**

## 3. 运算符的优先级
### 3.1 表格

| 优先级 |                   运算符                    | 结合律  |
| :-: | :--------------------------------------: | :--: |
|  1  |          后缀运算符：`[ ] ( ) · -> `           | 从左到右 |
|  2  |  单目运算符：`++ -- ! ~ +(正) -(负) * & sizeof`  | 从右到左 |
|  3  |              乘除法运算符：`* / %`              | 从左到右 |
|  4  |              加减法运算符：`+ - `               | 从左到右 |
|  5  |              移位运算符：`<< >> `              | 从左到右 |
|  6  |            关系运算符：`< <= > >=`             | 从左到右 |
|  7  |              相等运算符：`== != `              | 从左到右 |
|  8  |              位运算符 AND：`& `               | 从左到右 |
|  9  |              位运算符 XOR：`^ `               | 从左到右 |
| 10  |              位运算符 OR：`\| `               | 从左到右 |
| 11  |             逻辑运算符 AND：`&& `              | 从左到右 |
| 12  |             逻辑运算符 OR：`\|\| `             | 从左到右 |
| 13  |            条件 (三目) 运算符：`? : `            | 从右到左 |
| 14  | 赋值运算符：`= += -= *= /= %= &= ^= = <<= >>=` | 从右到左 |
| 15  |                逗号运算符：`,`                 | 从左到右 |

### 3.2 单目运算符

```c
n=(-x)++;//It's illegal!
n=-x++;//等同于 n=-x; x++;
```

- 对两个对象相同的单目运算符，采用**右结合**

- 自增运算符 ++ 和自减运算符 -- 的运算对象**只能是变量**, 不能是常量或者表达式

```c
*p.num=1; //此写法有误，. 运算符优先级高于 *
(*p).num=1; //正确写法1
p->num = 1; //正确写法2

*++p; //先让 p 自增，再取新地址，获得的值是 *(p+1);  
*p++; //取 *p，再 p=p+1;

(*p++)--; //先取 *p，再 p=p+1，最后 *p= *p-1 (括号内得到的值是 *p);
```

### 3.3.' -> ' 和 ' . ' 的使用

~~~ c
struct sk{
   int a; 
   double b;
} data, *p = &data
    
//p->a和(*p).a等价
//'*'优先级低于'.'
~~~

## 4. `sizeof ( )` 的用法

- `sizeof (x) `**不是**函数
- 在**编译**时确定其值, 计算出 x 在内存中所占字节数. 

所以, **括号内的赋值和函数, 不会被执行**, 编译与执行**无关**

```c
// char和'a'在被=动作前, 是两个独立类型, 没关联
char c = 'a';  
printf("%ld", sizeof(c));      // 结果:1, char类型是1字节
printf("%ld", sizeof('a')；    // 结果:4，’a'为整型常量
// 小心, 指针是地址, 指向某数据空间, 地址常是4字节.
char a[9]="GULUGULU";
char *p=a;
printf("%ld", sizeof(p) );      // 结果:4, 返回指针大小，指针本身就是一个无符号整型数.
printf("%ld", sizeof(a) );      // 9个*4字节=36字节
```

## 5. 函数调用中实参的个数

在函数调用 `Func(exp1 , exp2+exp3 , exp4*exp5)` 中，实参的数量是 3 。


在函数调用 `Func( (exp1, exp2+exp3, exp4*exp5) )` 中，实参的数量是 1 。

## 6. 数组与指针

-  `a[b]` 和 `*(a+b) ` 在使用时完全等价；
- 二维数组无法退化为二级指针；(数组 != 指针)
- 数组名不能被重新赋值。

### 例题

1. (C13A) Given the declaration: `int a[3][3]={1,2,3,4,5,6,7,8,9};`, the value of `a[-1][5]` is ?

    首先来看 `a[-1]`，即 `*(a-1)`，`a-1` 会以三个 int 为单位向左移动，即 `*(a-1)` 是一个指向如下位置的指针：
    ```c
       0 0 0 1 2 3 4 5 6 7 8 9
       ^
       |
    *(a-1) = p
    ```
    现在我们将 `a[-1]` 也就是 `*(a-1)` 视为 `p`，那我们要找的结果就是 `p[5]`，此时 `p` 是一个指向 int 类型的指针，`*(p+5)` 就相当于找到它指向的位置右侧第 5 个 int 的值，也就是 3。

2. (C17A) The following code fragment will output _.
    ~~~ c
    char *week[]={"Mon", "Tue","Wed","Thu","Fri","Sat","Sun"}, **pw=week;
    char c1, c2;
    c1 = (*++pw)[1];
    c2 = *++pw[1];
    printf("%c#%c#", c1, c2);
    ~~~

    首先 `c1 = (* ++pw)[1]`，`++pw` 使 `pw` 指向了 `week[1]`，然后 `(* ++pw)` 就是 `week[1]`，再加上 `[1]` 就是 `week[1][1]` 也就是 `'u'` 然后 `c2 = * ++pw[1]`，这里的理解方式一定是**对 `pw[1]` 进行 `++`**，`pw[1]` 此时是 `week[2]`，然后将其自增得到指向 `week[2][1]` 的指针，再解引用得到 `'e'`

3. 以下代码的输出为 ?
    ~~~ c
    int a[] = {1, 2, 3, 4, 5};
    int *p = a, *q = &a[2];
    printf("%lu", q-p);
    ~~~

    首先这道题的输出是 2 而不是 `2*sizeof (int)=8`，因为 q、p 指针相减的意义实际上是计算两个指针差了几个“单位”的距离，这里一个单位就是一个 int 的长度，它们差了两个 int，所以是 2

    **指针相减并不是将其值（也就是地址）相减**，如果这是预期行为，那么应该使用以下两种写法：

    ```c
    printf("%d", (int)q - (int)p); // 即 14 题中写法
    printf("%d", (char*)q - (char*)p); // 转为 char* 类型指针，单位就是一个字节，和地址相减效
    ```

4. 对于函数声明 `void f(char **p)`，以下哪个 `var` 的定义会使 `f(var)` 语法错误
    ```c
    A. char var[10][10];
    B. char *var[10];
    C. void *var = NULL;
    D. char *v=NULL, **var=&v;
    ```

    BD 一般没什么问题，大部分同学不理解 A 和 C

    - A. **二维数组不能退化为二级指针**，所以肯定是错的 

    - C. 在 C 语言中，`void *` 表示「**指向任意类型的指针**」，而这个「任意类型」也可以是 `char*`（即指向 char 的指针），所以它可以代表「指向指向 char 的指针的指针」（`char**`），所以是对的

5. 对于定义 `char s[2][3] = {"ab", "cd"}, \*p=(char\*)s`，以下哪个表达式是正确的且值等于 `s[1][1]`

    A. `*(s+3)`               
    B. `*s+2`               
    C. `p[1][1]`               
    D. `*++p+2 `

    ```c
    s -> {
        s[0] -> {'a', 'b', '\0'}
        s[1] -> {'c', 'd', '\0'}
    ```

    A. `*(s+3)` 等价于 `s[3]`，首先类型上它就不对
    B. 同样 `*s+2` 也是指针，类型上就肯定不对 
    C. `p` 此时是 `char *` 类型，不能进行两次解引用，语法错误
    D. `++p` 将 `p` 指到了 'b' 头上，解引用得到 'b' 再加二得到 'd' 等于 `s[1][1]`，选 D

## 7. 字符串

个人的理解方式是：C 语言中不存在字符串，只有字符数组，而字符串是一种对于字符数组的人为理解方式，即从开头直到第一个 '\0' 标志了一个字符串。所以 "abc" 和 {'a', 'b', 'c', '\0'} 是等价的。

另一个需要牢记的知识点是，当程序中出现字符串常量的时候，要将其视为**指向该字符串的首字符的指针**来处理。而且在初始化字符数组时除外（`char s[] = "abc"`; 并不是把 "abc" 首字符地址赋值给了 s）。

-  `char *s = "abc"` 和 `char s[] = "abc"` 不同
- 字符串常量实质上是一个指向字符串首字符的**指针常量**
- 字符串长度**不包括 `\0`** ,字符数组长度**包括 `\0`**

```c
char a[ ]="\\25ab, 0\n";
sizeof(a)=9;
strlen(a)=8;
```

### 例题

1. (C14A) The output of the code below is _.
    ```c
    char x[] = "hello,world\012345";
    printf("%d#%d#"，sizeof(x)，strlen(x));
    ```
    - 复习一下前面说过的字符字面量的表示

    这里 x 就相当于 `'h' 'e' 'l' 'l' 'o' ',' 'w' 'o' 'r' 'l' 'd', '\012' '3' '4' '5' '\0'`，所以 `sizeof (x)` 计算占了多少空间，一共 16 个字节，结果为 16。而 `strlen (x)` 计算第一个 '\0' 前有几个字符，这里有 15 个（'\012' 中的 \0 并不算 '\0'），结果为 15。

2. 以下代码段的输出为

    ```c
    char a[] = "abc";
    char b[] = {'a', 'b', 'c'};
    rintf("%d#%d#", sizeof(a), sizeof(b));
    ``

    "abc" 可以当作 {'a', 'b', 'c', '\0'}，所以 `sizeof(a) = 4，sizeof(b) = 3`

3. 以下代码是否存在错误，如果有请指出哪里有问题 

    ```c
    char *a = "hello";
    char b[] = "hello";
    a[0] = 'H';
    b[0] = 'H';
    ```

    - 这里我们要区分的是 a 和 b

    - A 就是一个字符指针，它指向了 "hello" 的开头，而这个 "hello" 存在于静态存储区中，是**只读**的，**不能进行修改**，所以 `a[0] = 'H'` 会在运行时产生错误（可以通过编译，但是运行会报错） 而 b 是一个字符数组，它自带了栈上空间，在初始化赋值的时候 "hello" 会被复制到 b 的空间中，所以 `b[0] = 'H'` 是**合法**的。

## 8. 野指针

声明一个指针只会分配一个给指针变量的空间（这部分空间用来存储它指向的位置的**地址值**），而不会分配指向的空间。使一个指针可用可以将其它变量取地址赋值给它，这样它指向的位置就是有效的。或者通过 malloc 来新分配一块堆上的内存，malloc 的返回值就是这块内存的首地址，也是你可用的。

## 9. 特殊表达式/语句

1. (C13A) After executing the code below, the value of y is 

    ```c
    int x = 0, y = 0, z = 0;
    z = (x==1) && (y=2);
    ```

    - **`||` 和 `&&` 的“短路”性质**：当 && 左边为假时，整体以定位假，则右边不再计算；当 || 左边为真时，整体一定为真，则右边不再计算。


    这里 `x==1` 已经为假，所以右侧的 `y=2` 不再执行，y 仍然为 0。

2. (C17A) After executing the following code fragment, the output is 

    ```c
    int i, b; i = b = 1;
    switch (i) {
        case 0: b += 1;
        case 1: b += 2;
        case 3: switch (b) {
            case 3: i++;
            default: break;
        }
        i += 1;
    }
    printf("%d#%d#", i, b);
    ```

    - Case 只规定了起点，而**何时退出 switch 块则由 break 决定**，只要没有遇到 break，则一直向下执行（即使碰到了下一个 case）

    - 这题里 i 为 1，进入了 case 1 中，b 变为了 3，紧接着因为没有 break 还会进入到 case 3 中，此时 b 为 3 进入了 case 3 执行了 `i++`，然后进入 default 执行了 break，退出后又执行了 `i+=1`，所以最终 i 和 b 都为 3。

3. 以下代码的输出为

    ```c
    int x = -1;
    printf("%d", (unsigned int)x);
    ```
    `unsigned int` 的转换并**不会改变** x 的二进制值（而是以无符号的方式来理解这段数据），而对于 printf 来说，它要输出的是一个 `%d`，即有符号数（无符号用 `%u`），所以输出时还是会**当作有符号整型来理解**，即输出 `-1`。

4. 以下代码的输出为 

    ```c
    char str[100] = "ZhejiangU 1 3 5", s[10];
    int n;
    sscanf(str, "%s %*d %d %*d", s, &n);
    printf("%s", &s[n]);
    ```

    `%*d` 表示读取一个整型，但是直接忽略，不存到变量中。所以 `sscanf` 读取到的 n 是第二个数字也就是 3，然后输出 `s[3]` 开始的字符串

5. Printf 参数传递

    ```c
    #include<stdio.h>
    #define ADD(x,y) x+y
    #define MUL(x,y) (x*y)
    #define POW(x) ((x)*(x))
    int main(){
        int a=1,b=2;
        printf("%d %d %d",\
        b*ADD(a,ADD(3,2*b)*2),\
        MUL(ADD(a,b),ADD(b,a)),\
        POW(ADD(++a,3)));
        return 0;
    }
    ```
    - 输出 17 10 30

    `printf ( )` 中参数传递顺序是**从后向前**，故在计算第三个表达式 POW 调用了两次 `++a`，使 a 的值变为 3

## 10. 书本内容

### Chapter 1. 引言

1. C 语言从 main 函数开始执行，多个 main 函数只执行第一个
2. 标识符由数字、字母、下划线组成，开头只能为字母或下划线
3. 保留字：主要和数据类型和语句有关， define 不是保留字，if、else 等是保留字
4. 编译生成的二进制文件后缀为' .obj '，可执行文件后缀是' .exe '

### Chapter 2. 用 C 语言编写程序

1. 输出格式控制：

	-  `%md` 指定输出宽度为 m (包含符号位)、向**右**对齐；
  
	- `%-md` 是向**左**对齐；

	- `%m.nf` 指定输出宽度为m (包含符号位和小数点)，保留**n 位小数**

2. for 语句

    ~~~c
    for(int i=1;i<=5;i++)
        sum=sum+i;// 1
        Printf ("%d\n", sum);// 2
    ~~~

    For 的循环体语句**只包含语句 1**

    ```c
    For (int i=1; i<=5; i++)；
        Sum=sum+i;// 1
        Printf ("%d\n", sum);// 2
    ```

    分号表示语句结束，循环体语句是**空语句**

### Chapter 3. 分支结构

1. 操作数和运算符之间必须连续输入，不能有空格
2. switch 语句如果 case 后没有**break**，就会继续往下执行，包括 default 后的语句
3. else 和**离它最近**的、**未和其他 else 匹配过**的 if 相匹配

### Chapter 4. 循环结构

1. continue 只能用于循环，用于跳过后面的语句继续循环
2. 内外层循环的循环变量不能相同
3. `while (i>0) {i++;}`**不会**死循环 (溢出后 i 又变为 0)

### Chapter 5. 函数

1. 函数首部：函数类型、函数名和形式参数表
2. 形参和实参一一对应，数量应相同，顺序应一致，类型建议保持一致
3. 函数定义中 void 不可省略，否则定义为 int
4. 局部变量和全局变量允许同名，函数的局部变量和复合语句的局部变量同名时以复合语句为准
5. 内存分布：

    | **静态存储区**（编译时确定） | 全局变量、静态局部变量            |
    | ---------------- | ---------------------- |
    | 动态存储区            | `main ()` 变量区、其他函数变量区域 |

- C 语言的全局变量, 静态局部变量的存储是在**编译时**确定的, 其存储空间的实际分配是在**程序开始执行前**完成

- C 语言的局部自动变量是在**进入变量定义所在的复合语句**时为它们分配存储单元, 这种大小静态确定

- 自动变量没有赋初值，为**随机值**；静态变量没有**赋初值为 0**，且静态变量赋初值仅在函数**第一次调用时**起作用

### Chapter 6. 回顾数据类型和表达式

#### 6.1 整型

- （最高位时符号位，1 表示负，0 表示正）, 此处用 -1 举例

| 原码     | `1000000000000001 `  | **最高位是符号位，其余是数值的绝对值的二进制** |
| ------ | -------------------- | ------------------------- |
| **反码** | `11111111111111110`  | **原码的符号位不变，余下取反**         |
| **补码** | `11111111111111111 ` | **反码的值加上 1**              |

C 语言规定，short 不长于 int，long 不短于 int，unsigned 表示存储无符号（最高位不作为符号位）

- 十进制：由正负号和 0~9 组成，首位数字不为 0

- 八进制：由正负号和 0~7 组成，首位数字一定为 0

- 十六进制：由正负号、数字 0~9 和英文 a ~ f (A ~ F) 组成，首位数字前必须有 0 x/0 X

- 后缀表示类型：l/L 表示 long，u/U 表示 unsigned，LU 表示 unsigned long

#### 6.2 实型
符号位+阶码+尾数
实型只能近似表示，运算也会产生误差

| **浮点表示法** | **由正负号，小数点和 0~9 组成，小数点前后至少有一边要有数字**  |
| -------------- | ------------------------------------------------------------ |
| **科学计数法** | **由正负号，e/E 和 0~9 组成，e 之前要有数据，e 之后指数只能是整数** |

#### 6.3 字符型
一个字节，用于储存 ASCII 码（0~127）
整型变量和字符型变量的定义和值可以相互转换 ch='A' ch=65
字符型常量：一堆单引号和括起来的字符表示

#### 6.4 输入输出

- `%d`: 十进制整数   
    
- `%u`：十进制无符号整数       

- `%o`：八进制整数       

- `%x`：十六进制整数 （ long 型加前缀 l ）

- `%f`: 小数类型（保留**六位**小数）     

- `%e`: 指数形式（小数点前有且仅有一位非零的数字）

```c
Int k=11;
Printf ("%d %o %x", k, k, k)//输出 11 13 b
printf ("%x %X % #x % #X ", k, k, k, k);//输出 b B 0 xb 0XB
printf ("%o % #o ", k, k, k, k);//输出 13 013
```

#### 6.5 类型转换

强制转换**不改变**数据定义，仅满足本次运算需要，强制类型转换是**右结合**的运算符

自动类型转换：

1. 非赋值运算：**先水平后垂直**，防止精度降低（精度从低到高）

2. 赋值运算：赋值号右侧表达式类型**自动转换**为赋值号左侧变量的类型

```c
z=(n>0)? 2.9:1;//输出 2.9 或 1.0
```

#### 6.6 位运算

- 左位移：右端的空位补 0，移到左端之外的舍弃

- 右位移：不带符号位的数据左端空位补 0，有符号位的数据左端空位按**符号位**复制，移到右端之外的舍弃

### Chapter 7. 数组

1. 数组长度定义时必须确定，初始化时若全部赋值则可以省略长度
2. 数组名是地址常量，**不允许修改**
3. 静态数组没有初始化则自动赋 0
4. 二维数组初始化时**可以省略行长度，不可省略列长度**

### Chapter 8. 指针

1. 区分内存单元的内容和内存单元的地址
2. 指针变量自身所占内存大小和所指向的变量类型**无关**，但不同类型的指针变量所占空间大小**相同**
3. 指针类型和所指变量类型**必须相同**，指针的值**只能**赋给**类型相同**的指针
4. 
```c
Int *p,*q;
Int a[10];
P=a;
Q=&a[5];
Printf ("%d", q-p);//输出 5
Printf ("%d", (int) q-(int) p);//输出 20
```

5. 字符串
`scanf`：遇到回车或空格就结束，将输入的数据和'\0'送入数组中（**不含回车和空格**）
`gets `：遇到回车结束，将输入的数据和'\0'送入数组中（**不含回车，可以包含空格**）
`puts`：遇到'\0'结束，将'\0'转换为'\n'输出
`strcpy(s1, s2)，strcat(s1, s2)`：s1 为**字符型数组基地址**，s2 为**字符数组名或字符串常量**
`strcmp(s1, s2)`：s1，s2 为**字符数组名或字符串常量**

6. 动态分配内存
`Malloc (size)`     
`calloc (n, size) `     
`realloc (void *ptr, size) `

7. 相同类型的指针 p , q ,可进行赋值 ( `p=q` ), 比较 ( `p!=q` ) 和算数运算 ( `p-q` , `p+1` ), 但**不能 `p+q`**

### Chapter 9. 结构

1. 嵌套结构，先定义成员的结构类型，再定义主结构类型
2. 结构类型变量的内存空间是各个成员所占内存空间之和

### Chapter 10. 函数与程序结构

1. 递归
2. 宏定义
	`#define ` 宏名宏定义字符串
	宏只是进行替换，所以要注意**括号**的使用
	编译预处理时无法计算表达式，故 ` #if ` 后**只能使用宏名**
3. 文件包含
	先从当前工位文件夹找文件，再到系统 include 文件夹中查找
4. 变量
	​  4.1 外部变量使用 extern 类型名变量名表; 来使用全局变量
​        4.2 静态全局变量用于限制全局变量作用域的拓展
​        4.3 函数使用 `extern 函数类型函数名 (参数表说明);` 来调用其他函数；`static 函数类型函数名 (参数表说明);` 来定义静态的函数

### Chapter 11. 指针进阶

1. 指针数组，二阶指针
2. 命令行参数  
```c
Int main (int argc, char *argv[])
{
     ...    
}                                 //argc 表示命令行参数（包括命令）个数，argv 存储命令行参数
```
3. 函数指针变量：`返回类型 (*变量名)(参数类型表);
```c
int (*fp)(int, int); // fp 是一个指向“接受两个 int、返回 int”的函数的指针
```
4. 链表插入原则：先连后断删除原则：先接后删

### Chapter 12. 文件

1. C 语言源程序是**文本文件**，目标文件和可执行文件是**二进制文件**
2. 文件系统分为**缓冲文件系统**和**非缓冲文件系统**，前者系统自动为每一个文件分配一块文件内存缓冲区（内存单元），后者在程序中用 C 语言实现分配
3. 磁盘数据的组织方式按**扇区**进行，每个扇区大小为 512 B，写满后操作系统自动把数据写入磁盘，把文件缓冲区清空

#### 关于文件的各类语法

| `FILE *fp`               | 定义一个 FILE 结构指针，用于指向文件（**不可进行  `fp++` 或 `*fp`**）                               |
| ------------------------ | ----------------------------------------------------------------------------- |
| `typedef`                | 重新命名已有类型，如 `typedef int NUM[10];` 语句执行后，`NUM a;` 等价于 `int a[10] ;`**（别忘了分号）** |
| `fopen ("文件名","文件打开方式")` | 成功返回地址，失败返回 NULL，**文件不能再关闭前被再次打开**<br>                                        |

| 打开方式（文本文件/二进制文件 ） | 含义               |
| :------------------------------- | :----------------- |
| **r/rb**                         | 打开文件只读       |
| **w/wb**                         | 建立新文件只写     |
| **a/ab**                         | 打开文件追加       |
| **r+/rb+**                       | 打开文件读/写      |
| **w+/wb+**                       | 建立新文件读/写    |
| **a+/ab+**                       | 打开文件读/写/追加 |

| 函数                                 | 作用                                                                                                 |
| ---------------------------------- | -------------------------------------------------------------------------------------------------- |
| `ffclose (文件指针)`                   | **成功的返回值为 0**，并把缓冲区数据写入磁盘，释放文件缓冲区单元和 FILE 结构，使文件指针和具体文件脱钩                                          |
| `exit(0)`                          | 关闭所有打开的文件，终止程序运行。**0 表示正常结束**，非 0 表示不正常结束。                                                         |
| `ch=fgetc(fp);`                    | 从 fp 所指的磁盘文件读入一个字符到 ch，读到有效字符后会向后移动指针，若读到末尾会读到无效字符并**返回 EOF**                                      |
| `fputc(ch, fp);`                   | 把 ch 写到 fp 所指的磁盘文件上                                                                                |
| `fputs (s, fp);`                   | 把字符串 s 写到 fp 所指的磁盘文件上，'\0'不写入文件；**成功则返回所写的最后一个字符，失败则返回 EOF**                                       |
| `fgets(s, n, fp);`                 | 最多读入 n-1 个字符到 s，并自动添加'\0'，会保留换行符但不保留 EOF；**成功返回读取的字符串，失败返回空指针**                                    |
| `fscanf (文件指针，格式字符串，输入表);`         |                                                                                                    |
| `fprintf(文件指针，格式字符串，输出表);`         |                                                                                                    |
| `fread(buffer, size, count, fp);`  | Buffer 为存放输入数据的首地址                                                                                 |
| `fwrite(buffer, size, count, fp);` | Buffer 为存放输入数据的首地址                                                                                 |
| `rewind(fp);`                      | 使指针回到文件首地址                                                                                         |
| `fseek(fp, offset, from);`         | 使指针向指定方向偏移指定单位长度; offset: 偏移量，long 型数据，加后缀 L；<br> `from`: 首部 0 SEEK_SET、当前 1 SEEK_CUR、尾部 2 SEEK_END |
| `ftell(fp);`                       | 相对于文件开头的位移量（字节数）                                                                                   |
| `foef(fp);`                        | 指针是否到文件末尾，**是则返回 1，否则返回 0**                                                                        |
| `ferror(fp);`                      | 文件使用输入输出函数时是否出错，**未出错返回 0**，否侧有错                                                                   |
| `clearerr(fp);`                    | 清除出错标志和文件结束标志，使它们为 0 值                                                                             |


          



          

         

      

          